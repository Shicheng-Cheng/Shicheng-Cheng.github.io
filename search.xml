<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[查缺补漏]]></title>
    <url>%2F2019%2F10%2F09%2F%E6%9F%A5%E7%BC%BA%E8%A1%A5%E6%BC%8F%2F</url>
    <content type="text"><![CDATA[surviror的from区可以创建对象吗在eden区创建，对象总在eden区出生，surviror的from区保存当前的幸存对象，to区则为空。 一次GC过程之后 eden区的对象+fron存储的对象 ——>复制到to区 清空eden区的对象+fron存储的对象 颠倒from区和to区的逻辑 线程池执行任务时，如何在某一个任务执行完毕返回结果，就立即停止线程池其他任务 signal 主线程CAS自旋+shutdownnow 设置一个容量为1的countdownlatch，然后countdownlatch返回后直接shutdownnow 用一个对象承载每个子任务的thread，然后一个子任务完成后，处理线程中断 CompletableFuture 的cancel()操作 秒杀扩展JVM（并发导致快速GC） +横向扩展+ 分布式压测 Volatile一个线程在读取使用volatile修饰的变量时，会将该线程中所有使用的变量从主内存中读取。 详细解释：JVM会尽力保证从主内存同步数据，当不加volatile时，看线程情况，会尽力同步主内存的额数据到线程内存中。 volatile修饰数组，其实是数组的地址是线程可见的，实际上数组内元素看上去”线程内可见”，是因为每次获取元素时数组都是从主内存中获取地址信息，再根据index得到元素。 AtomicIntegerArray 和AtomicReference对元素实现了volatile的读写。 sleep会增加同步主内存数据的机会。 当读一个volatile变量时，JMM会把该线程对应的本地内存置为无效，强制走主内存。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <categories>
        <category>基础知识</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>虚拟机</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[秒杀模块 (1)]]></title>
    <url>%2F2019%2F10%2F09%2F%E7%A7%92%E6%9D%80%E6%A8%A1%E5%9D%97%20%EF%BC%881%EF%BC%89%2F</url>
    <content type="text"><![CDATA[用到的技术栈，springboot，MyBatis，Redis,Druid,RabbitMq 实现分布式session 秒杀逻辑 添加spring-boot依赖和模板引擎依赖123456789101112131415 org.springframework.boot spring-boot-starter-parent 2.1.5.RELEASE org.springframework.boot spring-boot-starter-web org.springframework.boot spring-boot-starter-thymeleaf 2.0.4.RELEASE 在属性文件中添加关于模板引擎的配置，设置前缀和后缀。 12spring.thymeleaf.prefix=classpath:/templates/spring.thymeleaf.suffix=.html 添加Mysql依赖和Druid依赖在pom.xml中修改 1234567891011121314151617 org.mybatis.spring.boot mybatis-spring-boot-starter 1.3.2 mysql mysql-connector-java 8.0.13 com.alibaba druid 1.1.10 属性文件中添加 12345678910111213mybatis.type-aliases-package=com.hzc.secKill.Domain//下划线转成xml驼峰命名法mybatis.configuration.map-underscore-to-camel-case=truemybatis.configuration.default-fetch-size=100mybatis.configuration.default-statement-timeout=3000//配置文件扫描，接口类与xml文件放在一起mybatis.mapper-locations=classpath:com/hzc/secKill/DAO/*.xml//数据库名称为miaoshaspring.datasource.url=jdbc:mysql://localhost:3306/miaosha?useUnicode=true&characterEncoding=utf8&useSSL=false&serverTimezone=Asia/Shanghai&allowPublicKeyRetrieval=truespring.datasource.username=rootspring.datasource.password=xxxxspring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver 注意： 12345678@Mapper@Repositorypublic interface UserDAO { //@Param("id") 作为变量 @Select("select * from user where id = #{id}") public User getById(@Param("id") int id);} 配置redis在.conf文件中修改bind 0.0.0.0 因为之后要设置成分布式 daemonize yes允许后台运行 requirepass 123456 设置密码 1234redis-server ./redis.conf//查看进程ps -ef | grep redisredis-cli 1234567891011 redis.clients jedis 2.9.0 com.alibaba fastjson 1.2.47 新建redis文件夹，则添加redisconfig.class，使用@Component注解进行配置文件的扫描。 12345678910111213141516171819202122@Component@ConfigurationProperties(prefix = "redis")public class RedisConfig { private String host; private int port; public String getHost() { return host; } public void setHost(String host) { this.host = host; } public int getPort() { return port; } public void setPort(int port) { this.port = port; }} 修改下本地的ip地址，以及配置好密码 123spring.datasource.url=jdbc:mysql://127.0.0.1:3306/miaosha?useUnicode=true&characterEncoding=utf-8&allowMultiQueries=true&useSSL=falsespring.datasource.username=rootspring.datasource.password=admin 试试分布式压测 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <categories>
        <category>项目</category>
      </categories>
      <tags>
        <tag>springboot</tag>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IM通信系统 (2)]]></title>
    <url>%2F2019%2F10%2F09%2FIM%E9%80%9A%E4%BF%A1%E7%B3%BB%E7%BB%9F%20%20%20%20%20(2)%2F</url>
    <content type="text"><![CDATA[客户端的启动流程 初始化客户端，设置相应参数，配置线程模型，IO模型以及数据连接读写逻辑 connect（）方法是异步调用的，借助异步回调机制来实现指数退避重连逻辑 相对于服务端，客户端不需要调用childhandler( )方法，客户端不需要监听新连接的接入。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172import io.netty.bootstrap.Bootstrap;import io.netty.buffer.ByteBuf;import io.netty.channel.Channel;import io.netty.channel.ChannelFuture;import io.netty.channel.ChannelInitializer;import io.netty.channel.ChannelOption;import io.netty.channel.nio.NioEventLoopGroup;import io.netty.channel.socket.SocketChannel;import io.netty.channel.socket.nio.NioSocketChannel;import the.flash.protocol.PacketCodeC;import the.flash.protocol.request.MessageRequestPacket;import the.flash.util.LoginUtil;import java.util.Date;import java.util.Scanner;import java.util.concurrent.TimeUnit;public class NettyClient { private static final int MAX_RETRY = 5; private static final String HOST = "127.0.0.1"; private static final int PORT = 8000; public static void main(String[] args) { NioEventLoopGroup workerGroup = new NioEventLoopGroup(); //客户端启动的引导类,对应Bio中的socket,负责启动客户端并且连接服务端 Bootstrap bootstrap = new Bootstrap(); bootstrap //同样的，指定线程模型 .group(workerGroup) //指定IO模型 .channel(NioSocketChannel.class) //表示连接超时的时间 .option(ChannelOption.CONNECT_TIMEOUT_MILLIS, 5000) //这里的参数和服务端配置的参数一致 .option(ChannelOption.SO_KEEPALIVE, true) .option(ChannelOption.TCP_NODELAY, true) //给引导类指定一个handler，定义业务处理逻辑 .handler(new ChannelInitializer() { @Override public void initChannel(SocketChannel ch) { ch.pipeline().addLast(new ClientHandler()); } }); connect(bootstrap, HOST, PORT, MAX_RETRY); }//如果网络环境差，则会使用失败重连 private static void connect(Bootstrap bootstrap, String host, int port, int retry) { //bootsrap的conntect方法中有两个参数，第一个参数是IP，第二个参数是端口号 bootstrap.connect(host, port).addListener(future -> { if (future.isSuccess()) { System.out.println(new Date() + ": 连接成功，启动控制台线程……"); Channel channel = ((ChannelFuture) future).channel(); startConsoleThread(channel); } else if (retry == 0) { System.err.println("重试次数已用完，放弃连接！"); } else { // 第几次重连 int order = (MAX_RETRY - retry) + 1; // 本次重连的间隔 int delay = 1 < order; connect(bootstrap, host, port, retry - 1), delay, TimeUnit .SECONDS); } }); }} 如果在微服务的体系下，客户端不需要约定好端口，都是服务端启动并注册到微服务注册中心，注册host和port，客户端从注册中心获取服务端的信息即可。 此处使用定时任务逻辑，不使用sleep的原因： sleep（）需要处理Interrupted异常 可以交给专门的调度线程去做，主线程不会休眠。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <categories>
        <category>项目</category>
      </categories>
      <tags>
        <tag>netty</tag>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IM通信系统 （1）]]></title>
    <url>%2F2019%2F10%2F09%2FIM%E9%80%9A%E4%BF%A1%E7%B3%BB%E7%BB%9F%20%20%20%20%20(1)%2F</url>
    <content type="text"><![CDATA[服务端的启动流程 初始化服务端，设置相应参数，配置线程模型，IO模型以及数据连接读写逻辑 实现自动绑定端口逻辑 不仅需要监听本地端口，而且一直与客户端的连接进行交互。有两种类型的channel 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758import io.netty.bootstrap.ServerBootstrap;import io.netty.channel.ChannelInitializer;import io.netty.channel.ChannelOption;import io.netty.channel.nio.NioEventLoopGroup;import io.netty.channel.socket.nio.NioServerSocketChannel;import io.netty.channel.socket.nio.NioSocketChannel;import java.util.Date;public class NettyServer { private static final int PORT = 8000; public static void main(String[] args) { //表示监听端口，accept新连接的线程组 //参数中不需要设置成1，nio线程本身是懒启动 NioEventLoopGroup boosGroup = new NioEventLoopGroup(); //表示处理每一条连接的数据读写的线程组 NioEventLoopGroup workerGroup = new NioEventLoopGroup(); //服务端启动的引导类，可以对应Bio中的serversocket final ServerBootstrap serverBootstrap = new ServerBootstrap(); serverBootstrap //给引导类配置两大线程组 .group(boosGroup, workerGroup) //配置IO模型，指定为NIO .channel(NioServerSocketChannel.class) //给服务端的channel设置一些属性，表示系统临时存放已完成三次握手队列的最大长度 .option(ChannelOption.SO_BACKLOG, 1024) //表示开启TCP底层心跳机制 .childOption(ChannelOption.SO_KEEPALIVE, true) //表示开启Nagle方法，需要减少发送次数，以及减少网络交互，就开启 .childOption(ChannelOption.TCP_NODELAY, true) //给引导类创建一个ChannelInitializer，定义后序每条数据的连接读写 .childHandler(new ChannelInitializer() { protected void initChannel(NioSocketChannel ch) { ch.pipeline().addLast(new ServerHandler()); } });//原来的是serverfBootstrap.bind(8000)，这个方法是一个异步的方法，返回的是一个ChannelFuture, //可以给这个ChannelFuture添加一个监听器，在方法片段里添加判断端口是否绑定成功 bind(serverBootstrap, PORT); }//实现自动绑定端口逻辑 private static void bind(final ServerBootstrap serverBootstrap, final int port) { //lambda表达式 serverBootstrap.bind(port).addListener(future -> { if (future.isSuccess()) { System.out.println(new Date() + ": 端口[" + port + "]绑定成功!"); } else { System.err.println("端口[" + port + "]绑定失败!"); //不用lambda表达式的话，还要重新调用自身方法，并且将端口号+1 bind(serverBootstrap, port+1); } }); }} document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <categories>
        <category>项目</category>
      </categories>
      <tags>
        <tag>netty</tag>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据库索引]]></title>
    <url>%2F2019%2F10%2F08%2F%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B4%A2%E5%BC%95%2F</url>
    <content type="text"><![CDATA[document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <categories>
        <category>技术</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[算法思路汇总]]></title>
    <url>%2F2019%2F10%2F08%2F%E7%AE%97%E6%B3%95%E6%80%9D%E8%B7%AF%E6%B1%87%E6%80%BB%2F</url>
    <content type="text"><![CDATA[两个栈组成的队列关键在于一个栈作为压入栈，记为stack1，一个栈作为弹出栈，记为stack2，每次需要先判断stack2是否为空，只有当stack2为空时，才能将stack1中的所有元素压入stack2中。 12345if(stack2.isEmpty()){ while(!stack1.isEmpty()){ stack2.push(stack1.pop()); }} 打印两个有序链表的公共部分注意在判断两个链表的值相同时，要继续遍历链表 1234if(node1.val==node2.val){ node1=node1.next; node2=node2.next;} 单链表和双链表删除倒数第K个节点单链表删除 快慢指针法 可以先让fast指针先走k步，再让fast和slow一起继续遍历，直至fast为空。需要设立虚拟头结点dummyhead 先从头结点开始遍历链表，其中K值保持 K– ，遍历到链表尾部。若K小于0，再进行++K，当K等于0时，移动到的节点是待删除节点的前一个节点。若K=0,则直接返回头结点的下一个节点。 1234567if(K= 4) { if (pos == s.length()) ans.add(String.join(".", cur)); return; } // 分割得到ip地址的一段后，下一段只能在长度1-3范围内选择 for (int i = 1; i s.length()) break; String segment = s.substring(pos, pos+i); // 剪枝条件：不能以0开头，不能大于255 if (segment.startsWith("0") && segment.length() > 1 || (i == 3 && Integer.parseInt(segment) > 255)) continue; cur.add(segment); // 注意此处传的参数 backtracking(s, pos+i, cur, ans); cur.remove(cur.size()-1); } } public List restoreIpAddresses(String s) { List ans = new ArrayList(); backtracking(s, 0, new ArrayList(), ans); return ans; } 123456789101112131415161718public List letterCombinations(String digits) { if(digits.length()!=0){ dfs("", digits); } return result; } private void dfs(String combination, String digits) { if (digits.length() == 0) { result.add(combination); } else { String digit = digits.substring(0, 1); for (int i = 0; i < map1.get(digit).length(); i++) { String letter = map1.get(digit).substring(i, i + 1); dfs(combination + letter, digits.substring(1)); } } } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <categories>
        <category>算法与数据结构</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>最优解</tag>
        <tag>程序设计</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关键字]]></title>
    <url>%2F2019%2F10%2F08%2F%E5%85%B3%E9%94%AE%E5%AD%97%2F</url>
    <content type="text"><![CDATA[Staticstatic方法内部的变量是没有线程安全问题的，因为数据运行在栈里，线程是隔离开的。 static修饰的类变量，方法，代码块以及内部类，都属于类成员，不属于实例成员。 对static修饰的类变量，方法，代码块初始化顺序： 父类的静态变量和代码块比子类优先初始化； 其中静态变量和代码块在main方法之前便已经初始化。 在main方法之后父类构造器和子类构造器才开始初始化。 注意一种特殊情况： static修饰对象，注意其构造器内的语句先执行。 final final修饰的类，无法继承 修饰的方法，无法被覆写 修饰的变量，声明时必须初始化，也不能修改其内存地址 要举String的例子 try catch finally如果在try和catch中都遇到了异常，代码执行顺序是try -> catch -> finally 当finally执行后，再抛出异常 最终抛出的是catch的异常。 default一般使用在接口上，对于该接口，子类无须强制实现，但自己必须有默认实现。 比如集合中的Map利用default关键字新增各种方法。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <categories>
        <category>基础知识</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[源码系列]]></title>
    <url>%2F2019%2F10%2F08%2F%E6%BA%90%E7%A0%81%E7%B3%BB%E5%88%97%20%20--%20%20JDK%E7%9B%B8%E5%85%B3%2F</url>
    <content type="text"><![CDATA[String1234public final class String implements java.io.Serializable, Comparable, CharSequence { /** The value is used for character storage. */ private final char value[];} String 不可变的原因 String类被final修饰，不能被继承 保存的是一个char型数组，而且是private修饰 但可以通过反射进行修改。 123456String str="hello";Class clazz=Class.forName("java.lang.String");Field field=clazz.getDeclaredField("value");field.setAccessible(true);char[] value=(char[]) field.get(str); String.replace其中String.replace(char,char)要比String.replaceAll(String,String)性能好，字符在200左右就能看出差异。但relpaceAll()方法支持正则表达式，会对参数进行解析。 public String substring(int beginIndex)方法结束位置为文本末尾。 12this.value = Arrays.copyOfRange(value, offset, offset+count)//从字符数组进行一段范围的拷贝 重写equals方法1234567891011121314151617181920212223public boolean equals(Object anObject) { //先判断内存地址是否相同 if (this == anObject) { return true; } //判断比较的对象是否是String类型 if (anObject instanceof String) { String anotherString = (String)anObject; int n = value.length; if (n == anotherString.value.length) { char v1[] = value; char v2[] = anotherString.value; int i = 0; while (n-- != 0) { if (v1[i] != v2[i]) return false; i++; } return true; } } return false; } Long缓存内部实现了一种缓存机制，缓存了从-128到127内的所有long值。 1234567891011 private static class LongCache { private LongCache(){} static final Long cache[] = new Long[-(-128) + 127 + 1];//当容器初始化时，static修饰的代码块自动进行随之加载 static { //缓存long值。 for(int i = 0; i < cache.length; i++) cache[i] = new Long(i - 128); } } 工具类通用特征 构造器必须私有，使用时无须初始化 工具类的工具方法必须被static和final来修饰，保证方法不可变 Arrays.binarySearch() 用于快速从数组中查找出对应的值 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <categories>
        <category>底层源码</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java中的常量池种种]]></title>
    <url>%2F2019%2F09%2F28%2Fjava%E4%B8%AD%E7%9A%84%E5%B8%B8%E9%87%8F%E6%B1%A0%E7%A7%8D%E7%A7%8D%2F</url>
    <content type="text"><![CDATA[常量池的划分 Class 文件常量池 运行时常量池 字符串常量池 Class 文件常量池Class 文件常量池指的是编译生成的 class 字节码文件，其结构中有一项是常量池，用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后进入方法区的运行时常量池中存放。 什么是字面量和符号引用？字面量指字符串字面量和声明为 final 的（基本数据类型）常量值，这些字符串字面量除了类中所有双引号括起来的字符串(包括方法体内的)，还包括所有用到的类名、方法的名字和这些类与方法的字符串描述、字段(成员变量)的名称和描述符；方法内的常量值由栈分配，所以并不算是字面量。符号引用指指向 UTF-8 表中向这些字面量的引用，包括类和接口的全限定名(包括包路径的完整名)、字段的名称和描述符、方法的名称和描述符。只不过是以一组符号来描述所引用的目标，和内存并无关，所以称为符号引用，直接指向内存中某一地址的引用称为直接引用。 运行时常量池运行时常量池是方法区的一部分，是一块内存区域。Class 文件常量池将在类加载后进入方法区的运行时常量池中存放。 一个类加载到 JVM 中后对应一个运行时常量池，运行时常量池相对于 Class 文件常量池来说具备动态性，Class 文件常量只是一个静态存储结构，里面的引用都是符号引用。而运行时常量池可以在运行期间将符号引用解析为直接引用。 运行时常量池就是用来索引和查找字段和方法名称和描述符的。给定任意一个方法或字段的索引，通过这个索引最终可得到该方法或字段所属的类型信息和名称及描述符信息。 字符串常量池（Interned Strings）在 JDK1.6（含）之前也是方法区的一部分，并且其中存放的是字符串的对象。在 JDK1.7（含）之后，是在堆内存之中，存储的是字符串对象的引用，字符串实例是在堆中。 也就是说先在类加载完成，经过验证，准备阶段在堆中生成字符串对象实例，然后将对象实例的引用值存到字符串常量池中。 字符串常量池是全局的，JVM 中独此一份，即StringTable类，是一个哈希表，因此也称为全局字符串常量池。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <categories>
        <category>基础知识</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[并发编程-基础]]></title>
    <url>%2F2019%2F09%2F25%2F%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[上下文切换CPU通过时间片轮转算法来不断的切换线程以执行任务。所谓的上下文切换也就是，任务从保存到再加载的过程。 vmstat 测量上下文切换的次数 如何减少上下文切换 无锁并发编程 将数据ID按照Hash算法取模分段，不同线程处理不同段的数据。 CAS Atomic包，原子性 使用最少线程 协程操作 在单线程里实现多任务的调度，并在单线程里维持多个任务间的切换 避免死锁 避免一个线程持有多个锁 避免一个线程在锁内同时占用多个资源 使用定时锁 对于数据库锁，加锁和解锁在同一数据库连接中 volatile实现原理多出一行为lock前缀的汇编代码，从而将当前CPU缓存行的数据写回系统内存，这个写回内存的操作会使在其他CPU里缓存了该内存地址的数据无效。 其中LOCK信号会锁住总线，导致其他CPU不能访问总线，也就意味着不能访问内存。 追加64字节能提高并发编程效率部分处理器的缓存行是64个字节宽，不支持部分填充缓存行，若队列的头结点和尾结点都不足64字节的话，处理器会把他们都读到一个高速缓存行中，但当处理器试图修改头结点时，会锁定整个缓存行，导致尾结点不能被其他处理器所访问。 但无法保证原子性。例如AtomicInteger，值使用volatile修饰，保证多核下的可见性，数据修改时使用unsafe类，保证原子性。 synchronized实现原理AtomicLong的用法12345678910111213141516171819202122232425262728293031323334353637383940import java.util.concurrent.atomic.AtomicLong;public class Atomic { private static AtomicLong atomicLong = new AtomicLong(); private static Integer[] array1 = new Integer[]{0, 1, 3, 6, 0, 8, 10}; private static Integer[] array2 = new Integer[]{2, 3, 0, 6, 7}; public static void main(String[] args) throws InterruptedException { Thread thread1 = new Thread(new Runnable() { @Override public void run() { int size = array1.length; for (int i = 0; i < size; i++) { if (array1[i].intValue() == 0) { atomicLong.incrementAndGet(); } } } }); Thread thread2 = new Thread(new Runnable() { @Override public void run() { int size = array2.length; for (int i = 0; i < size; i++) { if (array2[i].intValue() == 0) { atomicLong.incrementAndGet(); } } } }); thread1.start(); thread2.start(); //join()必须加上，等待子线程执行完 thread1.join(); thread2.join(); System.out.println("打印0的个数为： " + atomicLong.get()); }} 两个线程各自统计自己所在数据中0的个数，调用AtomicLong的原子性递增方法。 伪共享因为多个变量被放入了一个缓存行，并且多个线程同时写入缓存行中的不同变量。 多个变量之所以会被放入一个缓存行，是因为缓存与内存交换数据的单位是缓存行，当CPU要访问的变量未在缓存命中，根据程序运行的局部性原理会将该变量在内存中大小为Cache的内存放在缓存行。 ThreadLocal用法12345678910111213141516171819202122232425262728public class ThreadLocalTest { static ThreadLocal localVariable=new ThreadLocal(); static void print(String str){ System.out.println(str+":"+localVariable.get());// localVariable.remove(); } public static void main(String[] args) { Thread thread1=new Thread(new Runnable() { @Override public void run() { localVariable.set("thread1"); print("thread1"); System.out.println("thread1 remove after"+":"+localVariable.get()); } }); Thread thread2=new Thread(new Runnable() { @Override public void run() { localVariable.set("thread2"); print("thread2"); System.out.println("thread2 remove after"+":"+localVariable.get()); } }); thread1.start(); thread2.start(); }} 输出示例（1）1234thread1:thread1thread1 remove after:thread1thread2:thread2thread2 remove after:thread2 将remove方法注释掉，打印输出实例。 输出示例（2）1234thread1:thread1thread1 remove after:nullthread2:thread2thread2 remove after:null 每个线程的本地变量是存到线程自己的内存变量threadLocals里面的，若当前线程一直不消失，则有可能造成内存泄漏，使用完毕一定要调用remove()方法将线程的变量threadLocals里的本地变量删除。 InheritableThreadLocals当父线程创建子线程时，构造函数里面会把父线程中的InheritableThreadLocals变量里面的本地变量拷贝一份复制到子线程的InheritableThreadLocals变量里。 这样，子线程便可以从父线程中获取到线程变量值了。 使用情境 存放用户登录信息 一些中间件需要统一的追踪ID将整个调用链路记录下来 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <categories>
        <category>并发编程</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[生产者消费者]]></title>
    <url>%2F2019%2F09%2F25%2F%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%2F</url>
    <content type="text"><![CDATA[生产者12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849import java.util.Random;import java.util.Vector;import java.util.concurrent.atomic.AtomicInteger;public class Producer implements Runnable { //使用volatile标志是否需要可见性，方便提供给stop()方法 private volatile boolean needProduce=true; //定义缓冲区 private final Vector sharequeue; //定义容量 private final int Size; //static修饰，既能计数，又能保证是线程安全的 private static AtomicInteger count=new AtomicInteger(); public Producer(Vector vector,int Size){ this.Size=Size; this.sharequeue=vector; } @Override public void run() { int data; Random random=new Random(); System.out.println("start product id= "+Thread.currentThread().getId()); try { while (needProduce){ //模拟延迟 Thread.sleep(random.nextInt(1000)); //当缓冲区大小达到最大容量，便阻塞 while (sharequeue.size()==Size){ synchronized (sharequeue){ System.out.println("Queue is full,produer "+Thread.currentThread().getId()+"is waiting "+sharequeue.size()); sharequeue.wait(); } } synchronized (sharequeue){ data=count.incrementAndGet(); sharequeue.add(data); System.out.println("create data: "+data+",size: "+sharequeue.size()); sharequeue.notifyAll(); } } }catch (InterruptedException e){ e.printStackTrace(); Thread.currentThread().interrupt(); } } public void stop(){ needProduce=false; }} 使用while循环是为了避免虚假唤醒。 消费者12345678910111213141516171819202122232425262728293031323334import java.util.Random;import java.util.Vector;public class Consumer implements Runnable { private final Vector sharequeue; public Consumer(Vector sharequeue) { this.sharequeue = sharequeue; } @Override public void run() { Random random = new Random(); System.out.println("start consumer id= " + Thread.currentThread().getId()); try { while (true) { Thread.sleep(random.nextInt(1000)); while (sharequeue.isEmpty()) { synchronized (sharequeue) { System.out.println("Queue is empty: ,consumer" + Thread.currentThread().getId() + "is running,size=" + sharequeue.size()); sharequeue.wait(); } } synchronized (sharequeue) { System.out.println("consumer consume data: " + sharequeue.remove(0) + ",size: " + sharequeue.size()); sharequeue.notifyAll(); } } } catch (InterruptedException e) { e.printStackTrace(); Thread.currentThread().interrupt(); } }} 主线程1234567891011121314151617181920212223242526272829303132import java.util.Vector;import java.util.concurrent.Executor;import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;public class Test { public static void main(String[] args) throws InterruptedException{ Vector vector=new Vector(); int size=4; ExecutorService executorService= Executors.newCachedThreadPool(); Producer producer1=new Producer(vector,size); Producer producer2=new Producer(vector,size); Producer producer3=new Producer(vector,size); Consumer consumer1=new Consumer(vector); Consumer consumer2=new Consumer(vector); Consumer consumer3=new Consumer(vector); executorService.execute(producer1); executorService.execute(producer2); executorService.execute(producer3); executorService.execute(consumer1); executorService.execute(consumer2); executorService.execute(consumer3); Thread.sleep(1000); producer1.stop(); producer2.stop(); producer3.stop(); Thread.sleep(3000); executorService.shutdown(); }} 输出示例12345678910111213141516171819202122232425262728293031323334start product id= 11start product id= 12start product id= 13start consumer id= 14start consumer id= 15start consumer id= 16Queue is empty: ,consumer 14 is running,size=0create data:1,size:1consumer consume data: 1,size: 0Queue is empty: ,consumer 14 is running,size=0create data:2,size:1consumer consume data: 2,size: 0create data:3,size:1create data:4,size:2consumer consume data: 3,size: 1create data:5,size:2consumer consume data: 4,size: 1consumer consume data: 5,size: 0Queue is empty: ,consumer 15 is running,size=0Queue is empty: ,consumer 14 is running,size=0Queue is empty: ,consumer 16 is running,size=0create data:6,size:1consumer consume data: 6,size: 0Queue is empty: ,consumer 14 is running,size=0Queue is empty: ,consumer 15 is running,size=0create data:7,size:1consumer consume data: 7,size: 0Queue is empty: ,consumer 14 is running,size=0Queue is empty: ,consumer 15 is running,size=0create data:8,size:1consumer consume data: 8,size: 0Queue is empty: ,consumer 14 is running,size=0Queue is empty: ,consumer 15 is running,size=0Queue is empty: ,consumer 16 is running,size=0 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <categories>
        <category>算法与数据结构</category>
      </categories>
      <tags>
        <tag>手撕算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[链表浅谈]]></title>
    <url>%2F2019%2F08%2F30%2F%E9%93%BE%E8%A1%A8%E6%B5%85%E8%B0%88%2F</url>
    <content type="text"><![CDATA[链表介绍 增加了虚拟头结点，即在索引0前面还有头结点，只需要遍历index次就可到达index的位置。 使用了内部类，即Node类 基本实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149public class LinkedList_New { class Node { private E e; private Node next; public Node(E e, Node next) { this.e = e; this.next = next; } public Node(E e) { this(e, null); } public Node() { this(null, null); } @Override public String toString() { return e.toString(); } } public int size; public Node dummyhead;// 虚拟头结点 public LinkedList_New() { size = 0; dummyhead = new Node(null, null); } public int getSize() { return size; } public boolean isEmpty() { return size == 0; } //向头结点插入元素，则关键在于iNULL3->2->1->0->NULL4->3->2->1->0->NULL4->3->66->2->1->0->NULL4->3->66->1->0->NULL3->66->1->0->NULL3->66->1->NULL 链表实现栈123456789101112131415161718192021222324252627282930313233public class LinklistStack implements Stack { private LinkedList_New list; public LinklistStack() { this.list = new LinkedList_New(); } @Override public int getSize() { return list.getSize(); } @Override public boolean isEmpty() { return list.isEmpty(); } @Override public void push(E e) { list.addNode(e);; } @Override public E pop() { return list.deleteFirst(); } @Override public E peek() { return list.getFirst(); } @Override public String toString() { StringBuilder stringBuilder=new StringBuilder(); stringBuilder.append("Stack: top "); stringBuilder.append(list); return stringBuilder.toString(); }} 性能比较与数组实现的栈进行入栈出栈的性能比较。 1234567891011121314151617181920212223import java.util.Random;public class StackTimeTest { public static double QueueTest(Stack s,int count) { long start=System.currentTimeMillis(); Random random=new Random(); for(int i=0;i < count;i++) { s.push(random.nextInt(Integer.MAX_VALUE)); } for(int i=0;i < count;i++) { s.pop(); } long end=System.currentTimeMillis(); return (end-start)/1000.0; } public static void main(String[] args) { int count=10000; double time1=QueueTest(new LinklistStack(), count); System.out.println("LinklistStack: "+time1+"s"); double time2=QueueTest(new ArrayStack(), count); System.out.println("ArrayStack: "+time2+"s"); } } 结果显示12LinklistStack: 0.006sArrayStack: 0.002s LinklistStack中包含更多的new 操作，增加了一定的时间复杂度。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <categories>
        <category>算法与数据结构</category>
      </categories>
      <tags>
        <tag>底层实现</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[煮酒论队列]]></title>
    <url>%2F2019%2F08%2F29%2F%E7%85%AE%E9%85%92%E8%AE%BA%E9%98%9F%E5%88%97%2F</url>
    <content type="text"><![CDATA[循环队列循环队列介绍 存在front和tail指针，当front==tail时，队列为空，当添加元素时，队列末尾指针即tail+1，而元素出队列时，则队列头指针front+1。 当（tail+1）%c ==front时，则队列满。实际上，对于整个队列来说，当队列满时，则实际上还剩余一个空间。 基本实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798public class LoopQueue implements Queue { public E[] data; //声明头指针和尾指针 public int front, tail; public int size; public LoopQueue(int capicity) { this.data = (E[]) new Object[capicity + 1]; front = 0; tail = 0; size = 0; } public LoopQueue() { this(10); } //由循环队列满的条件可知，队列元素的数量是整个队列长度-1 public int getCapicty() { return data.length-1; } @Override public int getSize() { return size; } @Override public boolean isEmpty() { return front==tail; } //入队操作，在队列满的条件下，进行扩容操作，对tail进行取余操作。这是与数组添加元素不一样的地方。 @Override public void enqueue(E e) { if((tail+1)%data.length==front) { resize(getCapicty()*2); } data[tail]=e; tail=(tail+1)%data.length; size++; } //扩容操作，声明一个新数组。 private void resize(int capicity) { E[] data_new=(E[]) new Object[capicity+1];// for(int i=0;i < size;i++) {// data_new[i]=data[(i+front)%data.length];// } for(int i=front;i!=tail;i=(i+1)%data.length) { data_new[i-front]=data[i]; } data=data_new; front=0; tail=size; } //出队操作，可以手动将队列头指针置为null，提醒GC进行回收，不影响最终的结果。 @Override public E dequeue() { if(isEmpty()) { throw new IllegalArgumentException("队列为空"); } E val=data[front];// data[front]=null; front=(front+1)%data.length; size--; if(size==getCapicty()/4 && getCapicty()/2!=0) { resize(getCapicty()/2); } return val; } @Override public E getFront() { if(isEmpty()) { throw new IllegalArgumentException("队列为空"); } return data[front]; } @Override public String toString() { StringBuilder stringBuilder = new StringBuilder(); stringBuilder.append(String.format("Queue size = %d,length: %d", size, getCapicty())); stringBuilder.append("front ["); for (int i = front; i != tail; i=(i+1)%data.length) { stringBuilder.append(data[i]); if ((i+1)%data.length!=tail) { stringBuilder.append(","); } } stringBuilder.append("] tail"); return stringBuilder.toString(); }} 测试示例123456789101112131415public class LoopQueueTest { public static void main(String[] args) { LoopQueue loopQueue=new LoopQueue(); for(int i=0;i1->NULL tail Queue Front: 0->1->2->NULL tail Queue Front: 1->2->NULL tail Queue Front: 1->2->3->NULL tail Queue Front: 1->2->3->4->NULL tail Queue Front: 1->2->3->4->5->NULL tail Queue Front: 2->3->4->5->NULL tail Queue Front: 2->3->4->5->6->NULL tail Queue Front: 2->3->4->5->6->7->NULL tail Queue Front: 2->3->4->5->6->7->8->NULL tail Queue Front: 3->4->5->6->7->8->NULL tail Queue Front: 3->4->5->6->7->8->9->NULL tail 性能比较与数组实现的队列以及链表实现的队列进行入队出队的性能比较。 12345678910111213141516171819202122232425262728import java.util.Random;public class QueueTimeTest { public static double QueueTest(Queue q,int count) { long start=System.currentTimeMillis(); Random random=new Random(); for(int i=0;i { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <categories>
        <category>算法与数据结构</category>
      </categories>
      <tags>
        <tag>底层实现</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[实现栈]]></title>
    <url>%2F2019%2F08%2F29%2F%E5%AE%9E%E7%8E%B0%E6%A0%88%2F</url>
    <content type="text"><![CDATA[创建功能接口1234567public interface Stack { int getSize(); boolean isEmpty(); void push(E e); E pop(); E peek();} 实现栈的功能借助之前实现的数组类，主要调用addLast和deleteLast方法。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556public class ArrayStack implements Stack { Array array; public ArrayStack(int capacity) { array = new Array(capacity); } public ArrayStack() { array=new Array(); } @Override public int getSize() { return array.getSize(); } @Override public boolean isEmpty() { return array.isEmpty(); } public int getCapicity() { return array.getCapacity(); } @Override public void push(E e) { array.addLast(e); } @Override public E pop() { return array.deleTeLast(); } @Override public E peek() { return array.getLast(); } @Override public String toString() { StringBuilder stringBuilder = new StringBuilder(); stringBuilder.append("Stack:"); stringBuilder.append("["); for (int i = 0; i < array.getSize(); i++) { stringBuilder.append(array.find(i)); if (i != array.getSize() - 1) { stringBuilder.append(","); } } stringBuilder.append("] top"); return stringBuilder.toString(); }} 测试类12345678910111213public class ArrayStackTest { public static void main(String[] args) { ArrayStack arrayStack=new ArrayStack() ; for(int i=0; i < 5;i++) { arrayStack.push(i); System.out.println(arrayStack); } arrayStack.pop(); System.out.println(arrayStack); }} 输出示例123456Stack:[0] topStack:[0,1] topStack:[0,1,2] topStack:[0,1,2,3] topStack:[0,1,2,3,4] topStack:[0,1,2,3] top document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <categories>
        <category>算法与数据结构</category>
      </categories>
      <tags>
        <tag>底层实现</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[实现数组类]]></title>
    <url>%2F2019%2F08%2F29%2F%E5%AE%9E%E7%8E%B0%E6%95%B0%E7%BB%84%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[实现一个数组类，实现了泛型，以及动态扩容。 内部实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184public class Array { public T[] data; private int count; //提供两个构造器 public Array(int num) { this.data = (T[]) new Object[num]; this.count = 0; } public Array() { this(10); } // 获得数组中元素个数 public int getSize() { return count; } // 获得数组长度 public int getCapacity() { return data.length; } // 判断数组是否为空 public boolean isEmpty() { return count == 0; } // 向所有元素后面添加一个新元素 public void addLast(T e) { insert(count, e); } // 向所有元素前面添加一个新元素 public void addFirst(T e) { insert(0, e); } // 插入新元素 public void insert(int index, T value) { if (data.length == count) { resize(); } if (index < 0 || index > count) { throw new IllegalArgumentException("数组已满"); } // 其中数组索引都是从0开始，所以起始位置已经是最后一个元素的下一位 for (int i = count; i > index; --i) { data[i] = data[i - 1]; } data[index] = value; ++count; } // 获取index位置的元素 public T find(int index) { if (index < 0 || index >= count) { throw new IllegalArgumentException("数组越界"); } else { return data[index]; } } // 修改数组中index位置的元素值 public void set(int index, T e) { if (index < 0 || index >= count) { throw new IllegalArgumentException("数组越界"); } data[index] = e; } // 查找数组元素e所在的索引值 public int get(T e) { for (int i = 0; i < data.length; i++) { if (data[i] == e) { return i; } } return -1; } //获取数组的第一个元素值 public T getFirst() { return find(0); } //获取数组的最后一个元素值 public T getLast() { return find(count-1); } // 删除元素，并返回元素值 public T delete(int index) { if (index < 0 || index >= count) { throw new IllegalArgumentException("数组越界"); } T ret = data[index]; for (int i = index + 1; i < count; i++) { data[i - 1] = data[i]; } if (count > 1)]; System.arraycopy(data, 0, newArray, 0, data.length); data = (T[]) newArray; } //缩小成原来的2倍 private void resize_less() { Object[] newArray = new Object[data.length/2]; System.arraycopy(data, 0, newArray, 0, count); data = (T[]) newArray; } // 重写打印方法 @Override public String toString() { StringBuilder stringBuilder = new StringBuilder(); stringBuilder.append(String.format("Array:size= %d,length: %d", count, data.length)); stringBuilder.append("["); for (int i = 0; i < count; i++) { stringBuilder.append(data[i]); if (i != count - 1) { stringBuilder.append(","); } } stringBuilder.append("]"); return stringBuilder.toString(); } public static void main(String[] args) { Array array = new Array(20); for (int i = 0; i < 10; i++) { array.addLast(i); } System.out.println(array); array.insert(3, 6); System.out.println(array); array.addFirst(-3); System.out.println(array); array.delete(2); System.out.println(array); array.deleteFirst(); System.out.println(array); array.removeElement(4); System.out.println(array); array.removeElement(3); System.out.println(array); array.addLast(4); array.addLast(7); array.addLast(8); System.out.println(array); }} 输出示例12345678Array:size= 10,length: 20[0,1,2,3,4,5,6,7,8,9]Array:size= 11,length: 20[0,1,2,6,3,4,5,6,7,8,9]Array:size= 12,length: 20[-3,0,1,2,6,3,4,5,6,7,8,9]Array:size= 11,length: 20[-3,0,2,6,3,4,5,6,7,8,9]Array:size= 10,length: 20[0,2,6,3,4,5,6,7,8,9]Array:size= 9,length: 10[0,2,6,3,5,6,7,8,9]Array:size= 8,length: 10[0,2,6,5,6,7,8,9]Array:size= 11,length: 15[0,2,6,5,6,7,8,9,4,7,8] document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <categories>
        <category>算法与数据结构</category>
      </categories>
      <tags>
        <tag>底层实现</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git遇到的系列问题]]></title>
    <url>%2F2019%2F08%2F27%2Fgit%E9%81%87%E5%88%B0%E7%9A%84%E7%B3%BB%E5%88%97%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[出现you need to resolve your current index first报错提示当使用git checkout 切换分支时会提示you need to resolve your current index first，使用如下命令即可解决。 1$ git reset --merge github上显示commit的Author与账户名称不符进入git bash,重新进行配置 12$ git config --global user.name "xxx" $ git config --global user.email "xxx" 出现Updates were rejected because the tip of your current branch is behind报错提示说明当前的分支代码不是最新的代码，需要更新一下master分支 push前先将远程repository修改pull下来 123$ git checkout master$ git pull origin master$ git push -u origin master git push时出现Everything up-to-date报错提示 如果之前未提交过文件，而你在git push的时候出现Everything up-to-date，并且文件也没有提交上去。可能是因为你没有git add 和 git commit。 也可能是git提交改动到缓存，要push的时候不会将本地所有的分支都push掉，所以出现这个问题。应该告诉git提交哪个分支。 这里有种特殊的情况是如果fork别人的仓库再clone到本地的话，即使git上只有一个主分支，他还是可能出现这个错误。那么我们就需要新建分支提交改动然后合并分支。 接下来先创建一个新分支提交改动 1$ git branch newbranch 然后输入这条命令检查是否创建成功 1$ git branch 终端输出 12 newbranch* master 这样就创建成功了，前面的*代表的是当前所在的工作分支。接下来就要切换工作分支。 1$ git checkout newbranch 可以 $ git branch 确认下。然后将改动提交到新的分支上。 12$ git add .$ git commit -a 此时可以 $ git status 检查下提交情况。如果提交成功，接下来就要回主分支了，代码和之前一样。 1$ git checkout master 然后将新分支提交的改动合并到主分支上 1$ git merge newbranch 合并分支可能产生冲突，下面的代码可以查看产生冲突的文件，然后做对应的修改再提交一次就可以了。 1$ git diff 接下来就可以push代码了。 1$ git push -u origin master 最后不能忘记删除分支 1$ git branch -D newbranch 如想保留分支只是想删除已经合并的部分只要把大写的D改成小写的d就行了。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>问题集合</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python技巧（2）]]></title>
    <url>%2F2019%2F08%2F21%2Fpython-skill-2%2F</url>
    <content type="text"><![CDATA[any的用法1if any(name.endwith('py') for name in files） 其中如startwith()与endwith()方法中如果有多个可匹配对象，必须输入一个元组。 分割字符串使用了多个界定符的情况下,界定符可以是逗号，分号，或者是空格，并且后面紧跟着任意个空格。需要注意是否使用了括号即捕获分组，形如(?:….)为非捕获分组。 12line='asdf fnfkjdjs,djjwe;djwe' a=re.split(r'(?:;|,|\s)\s*',line) 生成器表达式 如果想将字符串strip操作和其他迭代操作相结合，可以使用生成器表达式 1lines=(line.strip() for line in f 这种方式十分高效，因为不需要预先读取所有数据放到一个临时列表，仅仅只是创建一个生成器。 使用 + 操作符去连接大量的字符串效率低下，加号连接引起内存复制以及垃圾回收操作。也可以利用生成器表达式转换字符串并合并。 12data=['acm',3,4,5]dada_new=','.join(str(d) for d in data) python3.8新特性使用asyncio.run()高级API 12345678910import asyncioasync def print_hello(): print('hello') await asyncio.sleep(1) print('hello again')print('开始运行')asyncio.run(print_hello())print('进入循环') 函数的嵌套函数嵌套能保证内部函数的隐私，只能被外部函数所调用和访问，不会暴露在全局作用域，若函数内部有一些隐私数据（数据库用户以及密码),不想暴露在外面，就可以使用函数嵌套。 12345def connect(): def get_DB(): return host,username,password conn = connector.connect(get_DB()) return conn 同样的，合理使用函数嵌套，也可以提高程序的运行效率。使用递归的方式来计算一个数的阶乘，在计算之前，要检查输入是否合法。写成函数嵌套的话，输入是否合法只检查一次，而不使用嵌套的话，每调用一次递归，就会检查一次。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>相关技巧</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode:最长的斐波那契子序列的长度]]></title>
    <url>%2F2019%2F08%2F19%2Fleetcode-%E6%9C%80%E9%95%BF%E7%9A%84%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E5%AD%90%E5%BA%8F%E5%88%97%E7%9A%84%E9%95%BF%E5%BA%A6%2F</url>
    <content type="text"><![CDATA[题目内容如果序列 X_1, X_2, …, X_n 满足下列条件，就说它是 斐波那契式 的：n >= 3对于所有 i + 2 2 else 0 其中使用了迭代法，主要在于嵌套了三层循环，while的使用很重要。 Java解法1123456789101112131415161718192021class Solution { public int lenLongestFibSubseq(int[] A) { Map map=new HashMap(); for(int a=0;a < A.length;a++){ map.put(A[a],a); } int length=0; Map dict=new HashMap(); for(int k=0;k < A.length;++k){ for(int j=0;j < k;++j){ int result=map.getOrDefault(A[k]-A[j],-1); if (result=0){ int camp=dict.getOrDefault(result*A.length+j,2)+1; dict.put(j*A.length+k,camp); length=Math.max(length,camp); } } } return length>2 ? length :0; }} 使用动态规划，其中getOrDefault函数是可以获取对应键的值，如果值不存在，则提供第二个参数为默认值。可以将该问题抽象出数组索引的最长子序列问题，表达式为len(A[i,j])+1=len(A[j,k]),其中A[i,j]可以表示为i*A.length+j,若使用例如i+j来代替,则有的测试用例无法通过。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <categories>
        <category>算法与数据结构</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode:实现strStr()]]></title>
    <url>%2F2019%2F08%2F16%2Fleetcode-%E5%AE%9E%E7%8E%B0strStr%2F</url>
    <content type="text"><![CDATA[题目内容实现 strStr() 函数。 给定一个 haystack 字符串和一个 needle 字符串，在 haystack 字符串中找出 needle 字符串出现的第一个位置 (从0开始)。如果不存在，则返回 -1。 示例示例 1: 输入: haystack = “hello”, needle = “ll” 输出: 2 示例 2: 输入: haystack = “aaaaa”, needle = “bba” 输出: -1 类似C语言的 strstr() 以及 Java的 indexOf()函数。 python解法11234567891011class Solution(object): def strStr(self, haystack, needle): """ :type haystack: str :type needle: str :rtype: int """ for i in range(len(haystack)-len(needle)+1): if(haystack[i:len(needle)+i])==needle: return i return -1 重点在于循环范围是两个字符串的差值。 java解法11234567891011121314151617181920class Solution { public int strStr(String haystack, String needle) { if(needle.equals("")){ return 0; } if(haystack.equals("")){ return -1; } for(int i=0;ihaystack.length()) { return -1; } if(haystack.substring(i,i+needle.length()).equals(needle)){ return i; } } return -1; }} 该解法类似于python解法1，不过java要比python多出一些边界条件的限制，i+len(needle)与len(haystack）要进行比较，否则substring要报异常。 java解法2123456789101112131415161718192021222324252627282930class Solution { public int strStr(String haystack, String needle) { if(needle.equals("")){ return 0; } if(haystack.equals("")){ return -1; } if (haystack.equals(needle)){ return 0; } int j=0; int i; for(i=0;i < haystack.length();i++){ if (j==needle.length()){ return i-j; } if(haystack.charAt(i)==needle.charAt(j)){ ++j; }else{ i-=j; j=0; } } if (j==needle.length()){ return i-j; } return -1; }} 注意：存在这样一个测试用例： 12"mississippi""issip" 之所以在else语句里要加i=i-j，是因为需要考虑到之前有部分匹配的情况，需要将i返回到起初的下一位置。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <categories>
        <category>算法与数据结构</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[解决Maven索引补全问题]]></title>
    <url>%2F2019%2F08%2F16%2F%E8%A7%A3%E5%86%B3Maven%E7%B4%A2%E5%BC%95%E8%A1%A5%E5%85%A8%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[Maven无法自动补全依赖库 将下载好的spring的jar包放在./m2/responsity中，之后在maven的setting中手动更新本地仓库的jar索引来解决。 打开设置界面，选中本地的仓库，点击右上角的update，更新maven仓库索引。 这样对于已经下载到本地的jar都可以自动进行补全了。 缺少resource文件夹，设置成resource boot，即mark dectionary as source boot,可以在该文件夹下面建立包。 在pom.xml文件中直接添加依赖，然后点击右上角搜索框，输入maven project,点击刷新，可以对依赖库进行自动下载。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <categories>
        <category>Maven</category>
      </categories>
      <tags>
        <tag>问题集合</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python技巧（1）]]></title>
    <url>%2F2019%2F07%2F05%2Fpython-skill-1%2F</url>
    <content type="text"><![CDATA[星号的作用python利用*号对可迭代的对象进行解压，并赋值给多个对象。示例代码如下： 1234record = ['lakers','76ers','warriors'] *teams,team = record print(*teams)out：lakers 76ers 星号表达式也可以应用于列表的开始部分以及字符串的分割，若想解压一些元素而不使用，则使用一个普通的’_’或’ign’即可。在迭代元素为可变长元组的序列时很有用。示例代码如下： 1234567891011records = [ ('no1','76ers'), ('no2','warriors'), ('no1','bull')]def bar(s): print('no1',s)for tag,*args in records: if tag == 'no1': bar(*args)out:no1 76ers no1 bull 其中records为一个带有标签的元组序列 如何保留最后N个元素示例代码如下： 1234567from collections import dequedef search(lines,pattern,history = 5): previous = deque(maxlen=history) for line in lines: if pattern in line: yield line,previous previous.append(line) 在多行上做简单的文本匹配，并返回匹配所在行的最后N行。使用deque（maxlen=N)构造函数会新建一个固定大小的队列。当新的元素加入并且这个队列已满，最老的元素会自动被移除掉。 dict创建字典dict.fromkeys(“[…],[…]”) 第一个参数指定keys，第二个参数指定value 实现一个简单的优先级队列示例代码如下：Item类 12345678class Item(): def __init__(self,name): self.name=name def __repr__(self): return 'Item({})'.format(self.name)q=Priority()q.push(Item('foo'),1)q.pop() 12345678910import heapqclass Priority(): def __init__(self): self._queue=[] self._index=0 def push(self,item,prior): heapq.heappush(self._queue,(-prior,self._index,item)) self._index+=1 def pop(self): return heapq.heappop(self._queue)[-1] 字典中的键映射多个值d=defaultdict(list)d=setdefault('a',[]).append(1) 去重（return和yield的区别)示例代码如下： 12345678def deque(items): a=set() for item in items: if item not in a: #yield item a.add(item) return ac=list(deque([1,4,6,7,2,56,2,1])) 若是不用return，用yield编写生成器。示例代码如下： 123456789def dedupe(items,key=None): a=set() for item in items: var=item if key is None else key(item) if var not in a: yield item a.add(var)seed=[{'x':1,'y':2},{'x':3,'y':7},{'x':1,'y':2}]d=list(dedupe(seed,key=lambda x:x['x'])) 关于命名切片 内置的slice()函数创建了一个切片对象，可以用在任何切片允许使用的地方。 indices(sizde)返回一个三元组(start,stop,step)，所有值都会被合适的缩小以满足边界限制，避免出现indexError异常。for i in range(*a.indices(len(list))) 关键字排序使用itertools.groupby函数，扫描整个序列，并且查找连续相同值的元素序列。在此之前，是要会根据分组的字段进行预先排序。示例代码如下：rows.sort(key=itemgetter('date'))for date,item in groupby(rows,key=itemgetter('date')): 字典表达式示例代码如下：p={key:value for key,value in dict1.items() if key in list1}p=dict((key,value) for key,value in dict1.items() if value>80) 命名元组示例代码如下： 1234from collections import namedtupleinfo=namedtuple('info',['name','age'])sub=info('Tom',18)sub.age 好处是避免使用下标操作让代码表意不清，且非常依赖代码的结构。如果需要改变属性的值，使用命名元组实例的_replace()方法，它会创建一个全新的命名元组并将对应的字段用新的值来代替。当命名元组拥有可选或缺失字段的情况下，可以利用命名元组来填充数据，先创建一个包含缺省值的原型元组，使用_replace()方法创建新的值。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>相关技巧</tag>
      </tags>
  </entry>
</search>
