<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[队列的扩展--循环队列]]></title>
    <url>%2F2019%2F08%2F29%2F%E9%98%9F%E5%88%97%E7%9A%84%E6%89%A9%E5%B1%95-%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97%2F</url>
    <content type="text"><![CDATA[循环队列介绍 存在front和tail指针，当front==tail时，队列为空，当添加元素时，队列末尾指针即tail+1，而元素出队列时，则队列头指针front+1。 当（tail+1）%c ==front时，则队列满。实际上，对于整个队列来说，当队列满时，则实际上还剩余一个空间。 基本实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798public class LoopQueue implements Queue { public E[] data; //声明头指针和尾指针 public int front, tail; public int size; public LoopQueue(int capicity) { this.data = (E[]) new Object[capicity + 1]; front = 0; tail = 0; size = 0; } public LoopQueue() { this(10); } //由循环队列满的条件可知，队列元素的数量是整个队列长度-1 public int getCapicty() { return data.length-1; } @Override public int getSize() { return size; } @Override public boolean isEmpty() { return front==tail; } //入队操作，在队列满的条件下，进行扩容操作，对tail进行取余操作。这是与数组添加元素不一样的地方。 @Override public void enqueue(E e) { if((tail+1)%data.length==front) { resize(getCapicty()*2); } data[tail]=e; tail=(tail+1)%data.length; size++; } //扩容操作，声明一个新数组。 private void resize(int capicity) { E[] data_new=(E[]) new Object[capicity+1];// for(int i=0;i < size;i++) {// data_new[i]=data[(i+front)%data.length];// } for(int i=front;i!=tail;i=(i+1)%data.length) { data_new[i-front]=data[i]; } data=data_new; front=0; tail=size; } //出队操作，可以手动将队列头指针置为null，提醒GC进行回收，不影响最终的结果。 @Override public E dequeue() { if(isEmpty()) { throw new IllegalArgumentException("队列为空"); } E val=data[front];// data[front]=null; front=(front+1)%data.length; size--; if(size==getCapicty()/4 && getCapicty()/2!=0) { resize(getCapicty()/2); } return val; } @Override public E getFront() { if(isEmpty()) { throw new IllegalArgumentException("队列为空"); } return data[front]; } @Override public String toString() { StringBuilder stringBuilder = new StringBuilder(); stringBuilder.append(String.format("Queue size = %d,length: %d", size, getCapicty())); stringBuilder.append("front ["); for (int i = front; i != tail; i=(i+1)%data.length) { stringBuilder.append(data[i]); if ((i+1)%data.length!=tail) { stringBuilder.append(","); } } stringBuilder.append("] tail"); return stringBuilder.toString(); }} 测试示例123456789101112131415public class LoopQueueTest { public static void main(String[] args) { LoopQueue loopQueue=new LoopQueue(); for(int i=0;i { img.remove(); }); document.body.appendChild(img); });]]></content>
      <categories>
        <category>算法与数据结构</category>
      </categories>
      <tags>
        <tag>底层实现</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[实现栈]]></title>
    <url>%2F2019%2F08%2F29%2F%E5%AE%9E%E7%8E%B0%E6%A0%88%2F</url>
    <content type="text"><![CDATA[创建功能接口1234567public interface Stack { int getSize(); boolean isEmpty(); void push(E e); E pop(); E peek();} 实现栈的功能借助之前实现的数组类，主要调用addLast和deleteLast方法。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556public class ArrayStack implements Stack { Array array; public ArrayStack(int capacity) { array = new Array(capacity); } public ArrayStack() { array=new Array(); } @Override public int getSize() { return array.getSize(); } @Override public boolean isEmpty() { return array.isEmpty(); } public int getCapicity() { return array.getCapacity(); } @Override public void push(E e) { array.addLast(e); } @Override public E pop() { return array.deleTeLast(); } @Override public E peek() { return array.getLast(); } @Override public String toString() { StringBuilder stringBuilder = new StringBuilder(); stringBuilder.append("Stack:"); stringBuilder.append("["); for (int i = 0; i < array.getSize(); i++) { stringBuilder.append(array.find(i)); if (i != array.getSize() - 1) { stringBuilder.append(","); } } stringBuilder.append("] top"); return stringBuilder.toString(); }} 测试类12345678910111213public class ArrayStackTest { public static void main(String[] args) { ArrayStack arrayStack=new ArrayStack() ; for(int i=0; i < 5;i++) { arrayStack.push(i); System.out.println(arrayStack); } arrayStack.pop(); System.out.println(arrayStack); }} 输出示例123456Stack:[0] topStack:[0,1] topStack:[0,1,2] topStack:[0,1,2,3] topStack:[0,1,2,3,4] topStack:[0,1,2,3] top document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <categories>
        <category>算法与数据结构</category>
      </categories>
      <tags>
        <tag>底层实现</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[实现数组类]]></title>
    <url>%2F2019%2F08%2F29%2F%E5%AE%9E%E7%8E%B0%E6%95%B0%E7%BB%84%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[实现一个数组类，实现了泛型，以及动态扩容。 内部实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184public class Array { public T[] data; private int count; //提供两个构造器 public Array(int num) { this.data = (T[]) new Object[num]; this.count = 0; } public Array() { this(10); } // 获得数组中元素个数 public int getSize() { return count; } // 获得数组长度 public int getCapacity() { return data.length; } // 判断数组是否为空 public boolean isEmpty() { return count == 0; } // 向所有元素后面添加一个新元素 public void addLast(T e) { insert(count, e); } // 向所有元素前面添加一个新元素 public void addFirst(T e) { insert(0, e); } // 插入新元素 public void insert(int index, T value) { if (data.length == count) { resize(); } if (index < 0 || index > count) { throw new IllegalArgumentException("数组已满"); } // 其中数组索引都是从0开始，所以起始位置已经是最后一个元素的下一位 for (int i = count; i > index; --i) { data[i] = data[i - 1]; } data[index] = value; ++count; } // 获取index位置的元素 public T find(int index) { if (index < 0 || index >= count) { throw new IllegalArgumentException("数组越界"); } else { return data[index]; } } // 修改数组中index位置的元素值 public void set(int index, T e) { if (index < 0 || index >= count) { throw new IllegalArgumentException("数组越界"); } data[index] = e; } // 查找数组元素e所在的索引值 public int get(T e) { for (int i = 0; i < data.length; i++) { if (data[i] == e) { return i; } } return -1; } //获取数组的第一个元素值 public T getFirst() { return find(0); } //获取数组的最后一个元素值 public T getLast() { return find(count-1); } // 删除元素，并返回元素值 public T delete(int index) { if (index < 0 || index >= count) { throw new IllegalArgumentException("数组越界"); } T ret = data[index]; for (int i = index + 1; i < count; i++) { data[i - 1] = data[i]; } if (count > 1)]; System.arraycopy(data, 0, newArray, 0, data.length); data = (T[]) newArray; } //缩小成原来的2倍 private void resize_less() { Object[] newArray = new Object[data.length/2]; System.arraycopy(data, 0, newArray, 0, count); data = (T[]) newArray; } // 重写打印方法 @Override public String toString() { StringBuilder stringBuilder = new StringBuilder(); stringBuilder.append(String.format("Array:size= %d,length: %d", count, data.length)); stringBuilder.append("["); for (int i = 0; i < count; i++) { stringBuilder.append(data[i]); if (i != count - 1) { stringBuilder.append(","); } } stringBuilder.append("]"); return stringBuilder.toString(); } public static void main(String[] args) { Array array = new Array(20); for (int i = 0; i < 10; i++) { array.addLast(i); } System.out.println(array); array.insert(3, 6); System.out.println(array); array.addFirst(-3); System.out.println(array); array.delete(2); System.out.println(array); array.deleteFirst(); System.out.println(array); array.removeElement(4); System.out.println(array); array.removeElement(3); System.out.println(array); array.addLast(4); array.addLast(7); array.addLast(8); System.out.println(array); }} 输出示例12345678Array:size= 10,length: 20[0,1,2,3,4,5,6,7,8,9]Array:size= 11,length: 20[0,1,2,6,3,4,5,6,7,8,9]Array:size= 12,length: 20[-3,0,1,2,6,3,4,5,6,7,8,9]Array:size= 11,length: 20[-3,0,2,6,3,4,5,6,7,8,9]Array:size= 10,length: 20[0,2,6,3,4,5,6,7,8,9]Array:size= 9,length: 10[0,2,6,3,5,6,7,8,9]Array:size= 8,length: 10[0,2,6,5,6,7,8,9]Array:size= 11,length: 15[0,2,6,5,6,7,8,9,4,7,8] document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <categories>
        <category>算法与数据结构</category>
      </categories>
      <tags>
        <tag>底层实现</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git遇到的系列问题]]></title>
    <url>%2F2019%2F08%2F27%2Fgit%E9%81%87%E5%88%B0%E7%9A%84%E7%B3%BB%E5%88%97%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[出现you need to resolve your current index first报错提示当使用git checkout 切换分支时会提示you need to resolve your current index first，使用如下命令即可解决。 $ git reset --merge github上显示commit的Author与账户名称不符进入git bash,重新进行配置 git config --global user.name "xxx" git config --global user.email "xxx" 出现Updates were rejected because the tip of your current branch is behind报错提说明当前的分支代码不是最新的代码，需要更新一下master分支 push前先将远程repository修改pull下来 git checkout master git pull origin master git push -u origin master document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>问题集合</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python技巧（2）]]></title>
    <url>%2F2019%2F08%2F21%2Fpython-skill-2%2F</url>
    <content type="text"><![CDATA[any的用法1if any(name.endwith('py') for name in files） 其中如startwith()与endwith()方法中如果有多个可匹配对象，必须输入一个元组。 分割字符串使用了多个界定符的情况下,界定符可以是逗号，分号，或者是空格，并且后面紧跟着任意个空格。需要注意是否使用了括号即捕获分组，形如(?:….)为非捕获分组。 12line='asdf fnfkjdjs,djjwe;djwe' a=re.split(r'(?:;|,|\s)\s*',line) 生成器表达式 如果想将字符串strip操作和其他迭代操作相结合，可以使用生成器表达式 1lines=(line.strip() for line in f 这种方式十分高效，因为不需要预先读取所有数据放到一个临时列表，仅仅只是创建一个生成器。 使用 + 操作符去连接大量的字符串效率低下，加号连接引起内存复制以及垃圾回收操作。也可以利用生成器表达式转换字符串并合并。 12data=['acm',3,4,5]dada_new=','.join(str(d) for d in data) python3.8新特性使用asyncio.run()高级API 12345678910import asyncioasync def print_hello(): print('hello') await asyncio.sleep(1) print('hello again')print('开始运行')asyncio.run(print_hello())print('进入循环') 函数的嵌套函数嵌套能保证内部函数的隐私，只能被外部函数所调用和访问，不会暴露在全局作用域，若函数内部有一些隐私数据（数据库用户以及密码),不想暴露在外面，就可以使用函数嵌套。 12345def connect(): def get_DB(): return host,username,password conn = connector.connect(get_DB()) return conn 同样的，合理使用函数嵌套，也可以提高程序的运行效率。使用递归的方式来计算一个数的阶乘，在计算之前，要检查输入是否合法。写成函数嵌套的话，输入是否合法只检查一次，而不使用嵌套的话，每调用一次递归，就会检查一次。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>相关技巧</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode:最长的斐波那契子序列的长度]]></title>
    <url>%2F2019%2F08%2F19%2Fleetcode-%E6%9C%80%E9%95%BF%E7%9A%84%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E5%AD%90%E5%BA%8F%E5%88%97%E7%9A%84%E9%95%BF%E5%BA%A6%2F</url>
    <content type="text"><![CDATA[题目内容如果序列 X_1, X_2, …, X_n 满足下列条件，就说它是 斐波那契式 的：n >= 3对于所有 i + 2 2 else 0 其中使用了迭代法，主要在于嵌套了三层循环，while的使用很重要。 Java解法1123456789101112131415161718192021class Solution { public int lenLongestFibSubseq(int[] A) { Map map=new HashMap(); for(int a=0;a < A.length;a++){ map.put(A[a],a); } int length=0; Map dict=new HashMap(); for(int k=0;k < A.length;++k){ for(int j=0;j < k;++j){ int result=map.getOrDefault(A[k]-A[j],-1); if (result=0){ int camp=dict.getOrDefault(result*A.length+j,2)+1; dict.put(j*A.length+k,camp); length=Math.max(length,camp); } } } return length>2 ? length :0; }} 使用动态规划，其中getOrDefault函数是可以获取对应键的值，如果值不存在，则提供第二个参数为默认值。可以将该问题抽象出数组索引的最长子序列问题，表达式为len(A[i,j])+1=len(A[j,k]),其中A[i,j]可以表示为i*A.length+j,若使用例如i+j来代替,则有的测试用例无法通过。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <categories>
        <category>算法与数据结构</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode:实现strStr()]]></title>
    <url>%2F2019%2F08%2F16%2Fleetcode-%E5%AE%9E%E7%8E%B0strStr%2F</url>
    <content type="text"><![CDATA[题目内容实现 strStr() 函数。 给定一个 haystack 字符串和一个 needle 字符串，在 haystack 字符串中找出 needle 字符串出现的第一个位置 (从0开始)。如果不存在，则返回 -1。 示例示例 1: 输入: haystack = “hello”, needle = “ll” 输出: 2 示例 2: 输入: haystack = “aaaaa”, needle = “bba” 输出: -1 类似C语言的 strstr() 以及 Java的 indexOf()函数。 python解法11234567891011class Solution(object): def strStr(self, haystack, needle): """ :type haystack: str :type needle: str :rtype: int """ for i in range(len(haystack)-len(needle)+1): if(haystack[i:len(needle)+i])==needle: return i return -1 重点在于循环范围是两个字符串的差值。 java解法11234567891011121314151617181920class Solution { public int strStr(String haystack, String needle) { if(needle.equals("")){ return 0; } if(haystack.equals("")){ return -1; } for(int i=0;ihaystack.length()) { return -1; } if(haystack.substring(i,i+needle.length()).equals(needle)){ return i; } } return -1; }} 该解法类似于python解法1，不过java要比python多出一些边界条件的限制，i+len(needle)与len(haystack）要进行比较，否则substring要报异常。 java解法2123456789101112131415161718192021222324252627282930class Solution { public int strStr(String haystack, String needle) { if(needle.equals("")){ return 0; } if(haystack.equals("")){ return -1; } if (haystack.equals(needle)){ return 0; } int j=0; int i; for(i=0;i < haystack.length();i++){ if (j==needle.length()){ return i-j; } if(haystack.charAt(i)==needle.charAt(j)){ ++j; }else{ i-=j; j=0; } } if (j==needle.length()){ return i-j; } return -1; }} 注意：存在这样一个测试用例： 12"mississippi""issip" 之所以在else语句里要加i=i-j，是因为需要考虑到之前有部分匹配的情况，需要将i返回到起初的下一位置。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <categories>
        <category>算法与数据结构</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[解决Maven索引补全问题]]></title>
    <url>%2F2019%2F08%2F16%2F%E8%A7%A3%E5%86%B3Maven%E7%B4%A2%E5%BC%95%E8%A1%A5%E5%85%A8%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[Maven无法自动补全依赖库 将下载好的spring的jar包放在./m2/responsity中，之后在maven的setting中手动更新本地仓库的jar索引来解决。 打开设置界面，选中本地的仓库，点击右上角的update，更新maven仓库索引。 这样对于已经下载到本地的jar都可以自动进行补全了。 缺少resource文件夹，设置成resource boot，即mark dectionary as source boot,可以在该文件夹下面建立包。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <categories>
        <category>Maven</category>
      </categories>
      <tags>
        <tag>问题集合</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python技巧（1）]]></title>
    <url>%2F2019%2F07%2F05%2Fpython-skill-1%2F</url>
    <content type="text"><![CDATA[星号的作用python利用*号对可迭代的对象进行解压，并赋值给多个对象。示例代码如下： 1234record = ['lakers','76ers','warriors'] *teams,team = record print(*teams)out：lakers 76ers 星号表达式也可以应用于列表的开始部分以及字符串的分割，若想解压一些元素而不使用，则使用一个普通的’_’或’ign’即可。在迭代元素为可变长元组的序列时很有用。示例代码如下： 1234567891011records = [ ('no1','76ers'), ('no2','warriors'), ('no1','bull')]def bar(s): print('no1',s)for tag,*args in records: if tag == 'no1': bar(*args)out:no1 76ers no1 bull 其中records为一个带有标签的元组序列 如何保留最后N个元素示例代码如下： 1234567from collections import dequedef search(lines,pattern,history = 5): previous = deque(maxlen=history) for line in lines: if pattern in line: yield line,previous previous.append(line) 在多行上做简单的文本匹配，并返回匹配所在行的最后N行。使用deque（maxlen=N)构造函数会新建一个固定大小的队列。当新的元素加入并且这个队列已满，最老的元素会自动被移除掉。 dict创建字典dict.fromkeys(“[…],[…]”) 第一个参数指定keys，第二个参数指定value 实现一个简单的优先级队列示例代码如下：Item类 12345678class Item(): def __init__(self,name): self.name=name def __repr__(self): return 'Item({})'.format(self.name)q=Priority()q.push(Item('foo'),1)q.pop() 12345678910import heapqclass Priority(): def __init__(self): self._queue=[] self._index=0 def push(self,item,prior): heapq.heappush(self._queue,(-prior,self._index,item)) self._index+=1 def pop(self): return heapq.heappop(self._queue)[-1] 字典中的键映射多个值d=defaultdict(list)d=setdefault('a',[]).append(1) 去重（return和yield的区别)示例代码如下： 12345678def deque(items): a=set() for item in items: if item not in a: #yield item a.add(item) return ac=list(deque([1,4,6,7,2,56,2,1])) 若是不用return，用yield编写生成器。示例代码如下： 123456789def dedupe(items,key=None): a=set() for item in items: var=item if key is None else key(item) if var not in a: yield item a.add(var)seed=[{'x':1,'y':2},{'x':3,'y':7},{'x':1,'y':2}]d=list(dedupe(seed,key=lambda x:x['x'])) 关于命名切片 内置的slice()函数创建了一个切片对象，可以用在任何切片允许使用的地方。 indices(sizde)返回一个三元组(start,stop,step)，所有值都会被合适的缩小以满足边界限制，避免出现indexError异常。for i in range(*a.indices(len(list))) 关键字排序使用itertools.groupby函数，扫描整个序列，并且查找连续相同值的元素序列。在此之前，是要会根据分组的字段进行预先排序。示例代码如下：rows.sort(key=itemgetter('date'))for date,item in groupby(rows,key=itemgetter('date')): 字典表达式示例代码如下：p={key:value for key,value in dict1.items() if key in list1}p=dict((key,value) for key,value in dict1.items() if value>80) 命名元组示例代码如下： 1234from collections import namedtupleinfo=namedtuple('info',['name','age'])sub=info('Tom',18)sub.age 好处是避免使用下标操作让代码表意不清，且非常依赖代码的结构。如果需要改变属性的值，使用命名元组实例的_replace()方法，它会创建一个全新的命名元组并将对应的字段用新的值来代替。当命名元组拥有可选或缺失字段的情况下，可以利用命名元组来填充数据，先创建一个包含缺省值的原型元组，使用_replace()方法创建新的值。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>相关技巧</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F07%2F05%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
  </entry>
</search>
