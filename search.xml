<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[手撕Mysql]]></title>
    <url>%2F2019%2F10%2F22%2F%E6%89%8B%E6%92%95Mysql%2F</url>
    <content type="text"><![CDATA[Mysql基础说一下 MySQL 执行一条查询语句的内部执行过程？ 客户端先通过连接器连接到 MySQL 服务器。 连接器权限验证通过之后，先查询是否有查询缓存，如果有缓存（之前执行过此语句）则直接返回缓存数据，如果没有缓存则进入分析器。 分析器会对查询语句进行语法分析和词法分析，判断 SQL 语法是否正确，如果查询语法错误会直接返回给客户端错误信息，如果语法正确则进入优化器。 优化器是对查询语句进行优化处理，例如一个表里面有多个索引，优化器会判别哪个索引性能更好。 优化器执行完就进入执行器，执行器就开始执行语句进行查询比对了，直到查询到满足条件的所有数据，然后进行返回。 MySQL 提示“不存在此列”是执行到哪个节点报出的？此错误是执行到分析器阶段报出的，因为 MySQL 会在分析器阶段检查 SQL 语句的正确性。 MySQL 查询缓存的功能有何优缺点？MySQL 查询缓存功能是在连接器之后发生的，它的优点是效率高，如果已经有缓存则会直接返回结果。 查询缓存的缺点是失效太频繁导致缓存命中率比较低，任何更新表操作都会清空查询缓存，因此导致查询缓存非常容易失效。 如何关闭 MySQL 的查询缓存功能？MySQL 查询缓存默认是开启的，配置 querycachetype 参数为 DEMAND（按需使用）关闭查询缓存，MySQL 8.0 之后直接删除了查询缓存的功能。 MySQL 的常用引擎都有哪些？MySQL 的常用引擎有 InnoDB、MyISAM、Memory 等，从 MySQL 5.5.5 版本开始 InnoDB 就成为了默认的存储引擎。 MySQL 可以针对表级别设置数据库引擎吗？怎么设置？可以针对不同的表设置不同的引擎。在 create table 语句中使用 engine=引擎名（比如Memory）来设置此表的存储引擎。完整代码如下： 12345create table student( id int primary key auto_increment, username varchar(120), age int) ENGINE=Memory 常用的存储引擎 InnoDB 和 MyISAM 有什么区别？InnoDB 和 MyISAM 最大的区别是 InnoDB 支持事务，而 MyISAM 不支持事务，它们主要区别如下： InnoDB 支持崩溃后安全恢复，MyISAM 不支持崩溃后安全恢复。 InnoDB 存储文件有两个，后缀名分别是.frm和.idb，其中.frm是表的定义文件，而idb是数据文件。而Myisam的存储文件有三个，后缀名分别是.frm、.MYD、MYI，其中.frm是表的定义文件，.MYD是数据文件，.MYI是索引文件。但两者都是通过b+树来存储的。 Myisam引擎也是采用的B+Tree结构来作为索引结构。由于Myisam中的索引和数据分别存放在不同的文件，所以在索引树中的叶子节点中存的数据是该索引对应的数据记录的地址，由于数据与索引不在一起，所以Myisam是非聚簇索引。 InnoDB 支持行级锁，不过行锁是在命中索引的情况下才会起作用。MyISAM 不支持行级锁，只支持到表锁。 InnoDB 支持外键，MyISAM 不支持外键。 MyISAM由于有单独的索引文件，所以性能比 InnoDB 高。 MyISAM 支持 FULLTEXT 类型的全文索引，InnoDB 不支持 FULLTEXT 类型的全文索引，但是 InnoDB 可以使用 sphinx 插件支持全文索引，并且效果更好。 InnoDB 主键查询性能高于 MyISAM。、 Count(1)、Count(主键)、Count(*****) 有什么区别？ document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <categories>
        <category>技术</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[手撕Mysql]]></title>
    <url>%2F2019%2F10%2F22%2F%E6%89%8B%E6%92%95Mysqll%2F</url>
    <content type="text"><![CDATA[Mysql基础说一下 MySQL 执行一条查询语句的内部执行过程？ 客户端先通过连接器连接到 MySQL 服务器。 连接器权限验证通过之后，先查询是否有查询缓存，如果有缓存（之前执行过此语句）则直接返回缓存数据，如果没有缓存则进入分析器。 分析器会对查询语句进行语法分析和词法分析，判断 SQL 语法是否正确，如果查询语法错误会直接返回给客户端错误信息，如果语法正确则进入优化器。 优化器是对查询语句进行优化处理，例如一个表里面有多个索引，优化器会判别哪个索引性能更好。 优化器执行完就进入执行器，执行器就开始执行语句进行查询比对了，直到查询到满足条件的所有数据，然后进行返回。 MySQL 提示“不存在此列”是执行到哪个节点报出的？此错误是执行到分析器阶段报出的，因为 MySQL 会在分析器阶段检查 SQL 语句的正确性。 MySQL 查询缓存的功能有何优缺点？MySQL 查询缓存功能是在连接器之后发生的，它的优点是效率高，如果已经有缓存则会直接返回结果。 查询缓存的缺点是失效太频繁导致缓存命中率比较低，任何更新表操作都会清空查询缓存，因此导致查询缓存非常容易失效。 如何关闭 MySQL 的查询缓存功能？MySQL 查询缓存默认是开启的，配置 querycachetype 参数为 DEMAND（按需使用）关闭查询缓存，MySQL 8.0 之后直接删除了查询缓存的功能。 MySQL 的常用引擎都有哪些？MySQL 的常用引擎有 InnoDB、MyISAM、Memory 等，从 MySQL 5.5.5 版本开始 InnoDB 就成为了默认的存储引擎。 MySQL 可以针对表级别设置数据库引擎吗？怎么设置？可以针对不同的表设置不同的引擎。在 create table 语句中使用 engine=引擎名（比如Memory）来设置此表的存储引擎。完整代码如下： 12345create table student( id int primary key auto_increment, username varchar(120), age int) ENGINE=Memory 常用的存储引擎 InnoDB 和 MyISAM 有什么区别？InnoDB 和 MyISAM 最大的区别是 InnoDB 支持事务，而 MyISAM 不支持事务，它们主要区别如下： InnoDB 支持崩溃后安全恢复，MyISAM 不支持崩溃后安全恢复。 InnoDB 存储文件有两个，后缀名分别是.frm和.idb，其中.frm是表的定义文件，而idb是数据文件。而Myisam的存储文件有三个，后缀名分别是.frm、.MYD、MYI，其中.frm是表的定义文件，.MYD是数据文件，.MYI是索引文件。但两者都是通过b+树来存储的。 Myisam引擎也是采用的B+Tree结构来作为索引结构。由于Myisam中的索引和数据分别存放在不同的文件，所以在索引树中的叶子节点中存的数据是该索引对应的数据记录的地址，由于数据与索引不在一起，所以Myisam是非聚簇索引。 InnoDB 支持行级锁，不过行锁是在命中索引的情况下才会起作用。MyISAM 不支持行级锁，只支持到表锁。 InnoDB 支持外键，MyISAM 不支持外键。 MyISAM由于有单独的索引文件，所以性能比 InnoDB 高。 MyISAM 支持 FULLTEXT 类型的全文索引，InnoDB 不支持 FULLTEXT 类型的全文索引，但是 InnoDB 可以使用 sphinx 插件支持全文索引，并且效果更好。 InnoDB 主键查询性能高于 MyISAM。、 Count(1)、Count(主键)、Count(*****) 有什么区别？ document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <categories>
        <category>技术</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[广告系统开发-投放模块]]></title>
    <url>%2F2019%2F10%2F21%2F%E5%B9%BF%E5%91%8A%E7%B3%BB%E7%BB%9F%E5%BC%80%E5%8F%91-%E6%8A%95%E6%94%BE%E6%A8%A1%E5%9D%97%2F</url>
    <content type="text"><![CDATA[投放模块数据表设计 用户账户 推广计划（与推广单元是一对多） 推广单元 （与创意是多对多） 创意 层级设计 最高层级: 用户账户 第二层级: 推广计划 第三层级： 推广单元 关键词推广单元 地域推广单元 兴趣推广单元 人群推广单元 创意： 文字创意，图片创意等等 用户表 用户账户（ad_user) 含义 username 账户名称 token 账户token user_status 账号状态 create_time 创建时间 update_time 更新时间 推广计划表 推广计划(ad_plan) 含义 user_id 标记当前记录所属用户 plan_name 推广计划名称 plan_status 推广计划状态 start_date 推广计划开始时间 end_date 推广计划结束时间 create_time 创建时间 update_time 更新时间 推广单元表 推广单元（ad_unit) 含义 plan_id 关联推广计划id unit_name 推广单元名称 unit_status 推广单元状态 position_type 广告位类型 budget 预算 create_time 创建时间 update_time 更新时间 关键词推广单元 关键词限制（ad_unit_keyword) 含义 unit_id 关联推广单元id keyword 关键词 地域推广单元 关键词限制（ad_unit_district) 含义 unit_id 关联推广单元id province 省 city 市 兴趣推广单元 关键词限制（ad_unit_it) 含义 unit_id 关联推广单元id it_tag 兴趣标签 创意表 创意(ad_creative) 含义 name 创意名称 type 物料类型 material_type 物料子类型 height 高度 width 宽度 size 尺寸 duration 持续时长 audit_status 审核状态 user_id 标记当前所属用户 url 物料地址 create_time 创建时间 update_time 更新时间 由于创意与推广单元是多对多关系，因此还要有一个创意与推广单元关联表。 创意与推广单元关联表 创意与推广单元关联（creative_unit) 含义 creative_id 关联创意id unit_id 关联推广单元id 代码编写编写配置文件 12345678910111213141516171819202122232425262728293031server: port: 7000 servlet: context-path: /ad-sponsorspring: application: name: eureka-client-ad-sponsor jpa: show-sql: true hibernate: ddl-auto: none properties: hibernate.format_sql: true open-in-view: false datasource: url: jdbc:mysql://127.0.0.1:3306/ad_data?autoReconnect=true username: root password: admin tomcat: #最大连接数 max-active: 4 #最小空闲连接 min-idle: 2 #初始化连接 initial-size: 2eureka: client: service-url: defaultZone: http://server1:8000/eureka/ 定义数据表实体类（ad_user) 12345678910111213141516171819import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.cloud.client.circuitbreaker.EnableCircuitBreaker;import org.springframework.cloud.netflix.eureka.EnableEurekaClient;import org.springframework.cloud.openfeign.EnableFeignClients;//可以调用其他的微服务模块，不过在广告投放系统中不存在调用其他的微服务，只是可以令dashboard监控@EnableFeignClients//断路器@EnableCircuitBreaker//能够从服务注册中心中拿到其他微服务的信息@EnableEurekaClient@SpringBootApplicationpublic class SponsorApplication { public static void main(String[] args) { SpringApplication.run(SponsorApplication.class, args); }} 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980import com.imooc.ad.constant.CommonStatus;import lombok.AllArgsConstructor;import lombok.Data;import lombok.NoArgsConstructor;import javax.persistence.Basic;import javax.persistence.Column;import javax.persistence.Entity;import javax.persistence.GeneratedValue;import javax.persistence.GenerationType;import javax.persistence.Id;import javax.persistence.Table;import javax.persistence.Transient;import java.util.Date;@Data@NoArgsConstructor@AllArgsConstructor//标记实体类@Entity//标记对应的数据库中的表@Table(name = "ad_user")public class AdUser { //表明该字段为主键，@Id @Id //表明主键的生成策略 @GeneratedValue(strategy = GenerationType.IDENTITY) //表明字段名字 @Column(name = "id", nullable = false) private Long id; //表示数据库表的基本属性，也可以不写 @Basic @Column(name = "username", nullable = false) private String username; @Basic @Column(name = "token", nullable = false) private String token; @Basic @Column(name = "user_status", nullable = false) private Integer userStatus; @Basic @Column(name = "create_time", nullable = false) private Date createTime; @Basic @Column(name = "update_time", nullable = false) private Date updateTime; public AdUser(String username, String token) { this.username = username; this.token = token; //使用枚举类进行初始化 this.userStatus = CommonStatus.VALID.getStatus(); //创建时间和更新时间这两个字段使用new Date()进行初始化 this.createTime = new Date(); this.updateTime = this.createTime; }}/*定义枚举类型*/@Getterpublic enum CommonStatus { VALID(1, "有效状态"), INVALID(0, "无效状态"); private Integer status; private String desc; CommonStatus(Integer status, String desc) { this.status = status; this.desc = desc; }} 接下来编写ad_plan，ad_unit以及创意表，创意推广单元关联表对应的实体类，方式与上述代码基本一致。 定义数据表Dao接口(以AdUser实体类为例) 1234567891011import com.imooc.ad.entity.AdUser;import org.springframework.data.jpa.repository.JpaRepository;//继承spring-data jpa的接口，泛型中有两个参数，第一个是相关联的实体类，第二个参数是主键类型public interface AdUserRepository extends JpaRepository { /** * 根据用户名查找用户记录 * */ AdUser findByUsername(String username);} document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <categories>
        <category>项目</category>
      </categories>
      <tags>
        <tag>springcloud</tag>
        <tag>kafka</tag>
        <tag>Mysql</tag>
        <tag>分布式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[广告系统开发-通用模块]]></title>
    <url>%2F2019%2F10%2F21%2F%E5%B9%BF%E5%91%8A%E7%B3%BB%E7%BB%9F%E5%BC%80%E5%8F%91-%E9%80%9A%E7%94%A8%E6%A8%A1%E5%9D%97%2F</url>
    <content type="text"><![CDATA[通用模块 通用代码定义、配置定义 统一的响应处理 统一的异常处理 定义响应模板 1234567891011121314151617181920212223package com.imooc.ad.vo;import lombok.AllArgsConstructor;import lombok.Data;import lombok.NoArgsConstructor;import java.io.Serializable;//lombok注解@Data //相当于setter和getter构造器@NoArgsConstructor//无参构造器@AllArgsConstructor//全参构造器public class CommonResponse implements Serializable { private Integer code; private String message; private T data; public CommonResponse(Integer code, String message) { this.code = code; this.message = message; }} 进行统一响应的拦截 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061import com.imooc.ad.annotation.IgnoreResponseAdvice;import com.imooc.ad.vo.CommonResponse;import org.springframework.core.MethodParameter;import org.springframework.http.MediaType;import org.springframework.http.converter.HttpMessageConverter;import org.springframework.http.server.ServerHttpRequest;import org.springframework.http.server.ServerHttpResponse;import org.springframework.lang.Nullable;import org.springframework.web.bind.annotation.RestControllerAdvice;import org.springframework.web.servlet.mvc.method.annotation.ResponseBodyAdvice;//相当于返回json@RestControllerAdvicepublic class CommonResponseDataAdvice implements ResponseBodyAdvice { @Override @SuppressWarnings("all")//isAnnotationPresent()方法可能会造成空指针异常，可以将方法的warning隐藏起来 //通过方法参数或者类参数判断是否支持拦截 public boolean supports(MethodParameter methodParameter, Class aClass) { //通过方法参数拿到类的声明，类的声明被下面的自定义注解标识，不想受到响应拦截的影响，返回false if (methodParameter.getDeclaringClass().isAnnotationPresent( IgnoreResponseAdvice.class )) { return false; } //方法层面上，同上理解 if (methodParameter.getMethod().isAnnotationPresent( IgnoreResponseAdvice.class )) { return false; } return true; } @Nullable @Override @SuppressWarnings("all") //对CommonResponse进行统一拦截 public Object beforeBodyWrite(@Nullable Object o, MethodParameter methodParameter, MediaType mediaType, Class aClass, ServerHttpRequest serverHttpRequest, ServerHttpResponse serverHttpResponse) { //初始化统一响应的对象 CommonResponse response = new CommonResponse(0, ""); // o是返回对象，如果为空，直接返回0. if (null == o) { return response; } else if (o instanceof CommonResponse) { response = (CommonResponse) o; } else { response.setData(o); } return response; }} 自定义注解 12345678910import java.lang.annotation.ElementType;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;import java.lang.annotation.Target;//表明注解可以作用在类和方法上@Target({ElementType.TYPE, ElementType.METHOD})@Retention(RetentionPolicy.RUNTIME)public @interface IgnoreResponseAdvice {} 统一异常的处理 1234567891011121314151617181920212223package com.imooc.ad.advice;import com.imooc.ad.exception.AdException;import com.imooc.ad.vo.CommonResponse;import org.springframework.web.bind.annotation.ExceptionHandler;import org.springframework.web.bind.annotation.RestControllerAdvice;import javax.servlet.http.HttpServletRequest;//返回值也是统一响应的类型@RestControllerAdvicepublic class GlobalExceptionAdvice { //目标只是AdException类型 @ExceptionHandler(value = AdException.class) //传入两个参数，一个是http请求，一个是自定义异常 public CommonResponse handlerAdException(HttpServletRequest req, AdException ex) { CommonResponse response = new CommonResponse(-1, "business error"); response.setData(ex.getMessage()); return response; }} 统一配置 1234567891011121314151617181920212223package com.imooc.ad.conf;import org.springframework.context.annotation.Configuration;import org.springframework.http.converter.HttpMessageConverter;import org.springframework.http.converter.json.MappingJackson2HttpMessageConverter;import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;import java.util.List;@Configurationpublic class WebConfiguration implements WebMvcConfigurer { @Override //参数传进一个有多个http转换器的列表 public void configureMessageConverters(List converters) { //先清空 converters.clear(); //将java对象转化成json对象 converters.add(new MappingJackson2HttpMessageConverter()); }} document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <categories>
        <category>项目</category>
      </categories>
      <tags>
        <tag>springcloud</tag>
        <tag>kafka</tag>
        <tag>Mysql</tag>
        <tag>分布式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[广告系统开发-基础准备]]></title>
    <url>%2F2019%2F10%2F18%2F%E5%B9%BF%E5%91%8A%E7%B3%BB%E7%BB%9F%E5%BC%80%E5%8F%91-%E5%9F%BA%E7%A1%80%E5%87%86%E5%A4%87%2F</url>
    <content type="text"><![CDATA[相关基础Maven坐标： groupId: 工程组的标识。 artifactId: 工程的标识。 version: 工程版本号。 相关命令： mvn -v 查看maven版本 mvn compile 编译，将java源文件编译成class文件 mvn test 执行test目录下的测试用例 mvn package 打包，将java工程打成jar包 mvn clean 清理环境，清除target文件夹 相关特性： 传递依赖 项目引用了一个jar包，而该jar包又引用了其他jar包，maven会把直接引用和间接引用的jar包都下载到本地。 排除依赖：只想下载直接引用的jar包 (需要给出排除的jar包) 1234 xxx xxx 依赖冲突 项目中多个jar同时引用了相同的jar时，会产生依赖冲突。有以下两种避免冲突的策略： 短路优先 引用路径短的优先 声明优先 引用路径相同时，在pom.xml文件中谁先被声明，就使用谁。 多模块项目/聚合 父模块pom文件的配置：packing类型必须是pom 123xxxxxxpom 聚合子模块：使用modules标签 12345 xxx xxx xxx 父模块统一管理依赖包： 使用dependencyManagement标签 子模块需要在pom文件中声明父模块： 使用parent模块 项目右侧将maven的pom文件导入，重新reimport，便可以跳转类。 EurekaServer的开发单节点EurekaServer12345678910//两个注解表明是EurekaServer,是springboot应用启动程序@EnableEurekaServer@SpringBootApplicationpublic class EurekaApplication { public static void main(String[] args) { SpringApplication.run(EurekaApplication.class, args); }} 添加配置文件application.yml 123456789101112131415161718spring: application: name: ad-eurekaserver: port: 8000eureka: instance: hostname: localhost client: #是否同步 fetch-registry: false #是否注册 register-with-eureka: false #指出主机地址和服务器端口 service-url: defaultZone: http://${eureka.instance.hostname}:${server.port}/eureka/ 多节点EurekaServer修改配置文件 12345678910111213141516171819202122232425262728293031323334353637383940414243444546spring: application: name: ad-eureka #使用profiles文件去启动服务 profiles: server1server: port: 8000eureka:#实例信息，这里要修改hosts文件，相同ip地址会出现问题 instance: hostname: server1 prefer-ip-address: false client: service-url: #要指向另外两个节点 defaultZone: http://server2:8001/eureka/,http://server3:8002/eureka/---spring: application: name: ad-eureka profiles: server2server: port: 8001eureka: instance: hostname: server2 prefer-ip-address: false client: service-url: defaultZone: http://server1:8000/eureka/,http://server3:8002/eureka/---spring: application: name: ad-eureka profiles: server3server: port: 8002eureka: instance: hostname: server3 prefer-ip-address: false client: service-url: defaultZone: http://server1:8000/eureka/,http://server2:8001/eureka/ 修改hosts文件 1234127.0.0.1 server1127.0.0.1 server2127.0.0.1 server3 Eureka相关内容核心功能 Service Registry（服务注册） Service Discovery（服务发现） 基本架构Eureka 由三个角色组成： Eureka Server（这一章实现的功能），提供服务注册与发现 Service Provider，服务提供方，将自身服务注册到 Eureka Server 上，从而让 Eureka Server 持有服务的元信息，让其他的服务消费方能够找到当前服务 Service Consumer，服务消费方，从 Eureka Server 上获取注册服务列表，从而能够消费服务 Service Provider/Consumer 相对于 Server，都叫做 Eureka Client 高可用问题说明：单节点的 Eureka Server 虽然能够实现基础功能，但是存在单点故障的问题，不能实现高可用。因为 Eureka Server 中存储了整个系统中所有的微服务的元数据信息，单节点一旦挂了，所有的服务信息都会丢失，造成整个系统的瘫痪。 解决办法：搭建 Eureka Server 集群，让各个 Server 节点之间互相注册，从而实现微服务元数据的复制/备份，即使单个节点失效，其他的 Server 节点仍可以继续提供服务 元信息 Eureka Server中维护了系统中服务的，其中有两种：标准元数据和自定义元数据。标准元数据：主机名、IP地址、端口号、状态页和健康检查等信息，这些信息都会被发布在服务注册表中，用于服务之间的调用。自定义元数据：可以使用eureka.instance.metadata-map配置，这些元数据可以在远程客户端中访问，但是一般不改变客户端行为，除非客户端知道该元数据的含义。 如果我们在启动 Client（简单认为就是一个微服务）的时候，如果此时配置了错误的 Eureka Server 发现地址，或 Eureka Server 没有启动，那么，你会发现，Client 可以正常启动，但是不能完成注册。会抛出如下异常信息。 1234com.netflix.discovery.shared.transport.TransportException: Cannot execute request on any known server ...... at com.netflix.discovery.DiscoveryClient.register(DiscoveryClient.java:829) ~[eureka-client-1.9.2.jar:1.9.2] ...... 这里的异常信息，其实就告诉了我们，Client 向 Eureka Server 发起注册的过程。我们看一看 DiscoveryClient.register 里面做了什么 源码路径：eureka-client-1.9.2-sources.jar!/com/netflix/discovery/DiscoveryClient.java 123456789101112131415161718/** * 通过 HTTP （eurekaTransport） 请求将 Eureka Client 注册到 Eureka Server 上 */boolean register() throws Throwable { logger.info(PREFIX + "{}: registering service...", appPathIdentifier); EurekaHttpResponse httpResponse; try { // 很显然，这里的 instanceInfo 就是 Client 的元数据 httpResponse = eurekaTransport.registrationClient.register(instanceInfo); } catch (Exception e) { logger.warn(PREFIX + "{} - registration failed {}", appPathIdentifier, e.getMessage(), e); throw e; } if (logger.isInfoEnabled()) { logger.info(PREFIX + "{} - registration status: {}", appPathIdentifier, httpResponse.getStatusCode()); } return httpResponse.getStatusCode() == 204;} instanceInfo 就是 com.netflix.appinfo.InstanceInfo 的对象实例，它被称作是 “应用实例信息”。所以，这个对象中包含的属性，最终会投递到 Eureka Server 中，也就是说，Eureka Server 维护的元信息就是 InstanceInfo 。 元信息的保存 其中，涉及到元信息的保存，可能是Eureka Server内部维护着一张表来记录这些元信息，Eureka服务器没有后端存储，但注册表中的服务实例必须发送心跳信号以保持其注册是最新的，所以这可能使内存中完成。客户端可能还拥有一个eureka注册的内存缓存，这样，client不必为每个服务请求都去注册表。 Client 向 Server 发起注册（Http 请求），那么Server 必须对外提供这个接口才可以。经过追踪 Server 端的源码（eureka-core-1.9.2-sources.jar），很容易可以找到 源码路径：com/netflix/eureka/resources/ApplicationResource.java，其中 addInstance 方法即实现了服务注册的功能（Server 端）。源码如下： 12345678910111213141516171819@POST@Consumes({"application/json", "application/xml"})public Response addInstance(InstanceInfo info, @HeaderParam(PeerEurekaNode.HEADER_REPLICATION) String isReplication) { // 校验 instanceinfo 中是否包含必须的属性 if (isBlank(info.getId())) { return Response.status(400).entity("Missing instanceId").build(); } else if (isBlank(info.getHostName())) { return Response.status(400).entity("Missing hostname").build(); } ...... // 注册信息校验 ...... // 通过 PeerAwareInstanceRegistry 的 register 方法完成 Client 的注册 registry.register(info, "true".equals(isReplication)); return Response.status(204).build();} 我们再去看 PeerAwareInstanceRegistry 的实现类：org.springframework.cloud.netflix.eureka.server.InstanceRegistry 的 register 方法的实现： 123456public void register(final InstanceInfo info, final boolean isReplication) { //传播 Client 的注册消息 handleRegistration(info, resolveInstanceLeaseDuration(info), isReplication); //调用父类 com.netflix.eureka.registry.AbstractInstanceRegistry 的 register 方法 super.register(info, isReplication);} 继续看 AbstractInstanceRegistry 的 register 方法的实现： 1234567891011121314151617181920212223242526public void register(InstanceInfo registrant, int leaseDuration, boolean isReplication) { try { read.lock(); // registry 存储了注册信息, 它是一个两层的 Map 结构 // ConcurrentHashMap registry Map gMap = registry.get(registrant.getAppName()); REGISTER.increment(isReplication); if (gMap == null) { final ConcurrentHashMap gNewMap = new ConcurrentHashMap(); gMap = registry.putIfAbsent(registrant.getAppName(), gNewMap); if (gMap == null) { gMap = gNewMap; } } Lease existingLease = gMap.get(registrant.getId()); ...... Lease lease = new Lease(registrant, leaseDuration); if (existingLease != null) { lease.setServiceUpTimestamp(existingLease.getServiceUpTimestamp()); } gMap.put(registrant.getId(), lease); ...... } finally { read.unlock(); }} InstanceInfo 中的元数据信息存储在一个 ConcurrentHashMap 对象中。Eureka Server 使用了两层 Map 结构做存储，第一层的 key 存储服务名：InstanceInfo 中的 appName 属性，第二层 key 存储实例名：InstanceInfo 中的 instanceId 属性。 微服务架构以及网关介绍微服务架构的两种方式： 点对点的方式：服务之间直接调用，每个微服务都开放Rest API，并调用其他微服务的接口。 API-网关方式：业务接口通过API网关暴露，是所有客户端接口的唯一入口，微服务之间的通信也通过API网关。 Zuul 的生命周期：Zuul 提供了服务网关的功能，可以实现负载均衡、反向代理、动态路由、请求转发等功能。Zuul 大部分功能都是通过过滤器实现的，Zuul 中定义了四种标准的过滤器类型，同时，还支持自定义过滤器。 Pre filters:在请求路由之前被调用，实现身份验证，在集群中选择请求的微服务。 Routing filters: 请求路由到微服务 Post filters：响应http头，收集统一信息和指标。将响应微服务发送给客户端。在 route 和 error 过滤器之后被调用 Error filters: 处理请求时发生错误时被调用。 网关启动程序的开发1234567891011//开启网关代理@EnableZuulProxy//注意此处是SpringCloudApplication，而不是SpringBootApplication@SpringCloudApplicationpublic class ZuulGatewayApplication { public static void main(String[] args) { SpringApplication.run(ZuulGatewayApplication.class, args); }} 编写配置文件 123456789server: port: 9000spring: application: name: ad-gatewayeureka: client: service-url: defaultZone: http://server1:8000/eureka/ 自定义网关过滤器实现打印访问日志，记录访问的延迟，从请求到返回经历了多少时间的功能。 编写Pre filter 123456789101112131415161718192021222324252627282930313233343536import com.netflix.zuul.ZuulFilter;import com.netflix.zuul.context.RequestContext;import com.netflix.zuul.exception.ZuulException;import lombok.extern.slf4j.Slf4j;import org.springframework.cloud.netflix.zuul.filters.support.FilterConstants;import org.springframework.stereotype.Component;@Slf4j//当作组件进行注入@Componentpublic class PreRequestFilter extends ZuulFilter { //定义过滤器类型 @Override public String filterType() { return FilterConstants.PRE_TYPE; } //定义执行顺序，数字越小，执行顺序越高 @Override public int filterOrder() { return 0; } //验证 @Override public boolean shouldFilter() { return true; } @Override public Object run() throws ZuulException { //记录当前时间，请求上下文会一直传递下去 RequestContext ctx = RequestContext.getCurrentContext(); ctx.set("startTime", System.currentTimeMillis()); return null; }} 编写Post filter 12345678910111213141516171819202122232425262728293031323334353637383940414243444546import com.netflix.zuul.ZuulFilter;import com.netflix.zuul.context.RequestContext;import com.netflix.zuul.exception.ZuulException;import lombok.extern.slf4j.Slf4j;import org.springframework.cloud.netflix.zuul.filters.support.FilterConstants;import org.springframework.stereotype.Component;import javax.servlet.http.HttpServletRequest;/** * Created by Qinyi. */@Slf4j@Componentpublic class AccessLogFilter extends ZuulFilter { @Override public String filterType() { return FilterConstants.POST_TYPE; } @Override public int filterOrder() { return FilterConstants.SEND_RESPONSE_FILTER_ORDER - 1; } @Override public boolean shouldFilter() { return true; } @Override public Object run() throws ZuulException { RequestContext context = RequestContext.getCurrentContext(); //取出当前请求的uri HttpServletRequest request = context.getRequest(); Long startTime = (Long) context.get("startTime"); String uri = request.getRequestURI(); long duration = System.currentTimeMillis() - startTime; log.info("uri: " + uri + ", duration: " + duration / 100 + "ms"); return null; }} document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <categories>
        <category>项目</category>
      </categories>
      <tags>
        <tag>springcloud</tag>
        <tag>kafka</tag>
        <tag>Mysql</tag>
        <tag>分布式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[海量数据]]></title>
    <url>%2F2019%2F10%2F17%2F%E6%B5%B7%E9%87%8F%E6%95%B0%E6%8D%AE%2F</url>
    <content type="text"><![CDATA[document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <categories>
        <category>技术</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[手撕dubbo]]></title>
    <url>%2F2019%2F10%2F17%2F%E6%89%8B%E6%92%95dubbo%2F</url>
    <content type="text"><![CDATA[Dubbo如何保证极高的可扩展性12第一点，是核心的组件全部接口化，组件和组件之间的调用，必须全部是依托于接口，去动态找配置的实现类，如果没有配置就用他自己默认的第二点，提供一种自己实现的组件的配置的方式，比如说你要是自己实现了某个组件，配置一下，人家到时候运行的时候直接找你配置的那个组件即可，作为实现类，不用自己默认的组件了 dubbo自己实现了一套SPI机制，比如protocol接口的SPI(“dubbo”), 就默认使用DubboProtocol。 基于Dubbo的调用该如何实现动态协议进而实现服务的调用 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <categories>
        <category>dubbo</category>
      </categories>
      <tags>
        <tag>中间件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[消息中间件]]></title>
    <url>%2F2019%2F10%2F11%2F%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[MQ 推拉模式以及优缺点ActiveMQ是一个消息中间件，对于消费者而言有两种方式从消息中间件获取消息。 Push方式：由消息中间件主动地将消息推送给消费者； Pull方式：由消费者主动向消息中间件拉取消息而采用Pull方式，会增加消息的延迟，即消息到达消费者的时间有点长。但是，Push方式会有一个坏处：如果消费者的处理消息的能力很弱(一条消息需要很长的时间处理)，而消息中间件不断地向消费者Push消息，消费者的缓冲区可能会溢出。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <categories>
        <category>技术</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[手撕网络协议]]></title>
    <url>%2F2019%2F10%2F11%2F%E6%89%8B%E6%92%95%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%2F</url>
    <content type="text"><![CDATA[document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <categories>
        <category>技术</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[容器类]]></title>
    <url>%2F2019%2F10%2F11%2F%E5%AE%B9%E5%99%A8%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[ArrayList 和Vector不同，ArrayList中的操作是线程不安全的。所以，建议在单线程中才使用ArrayList，而在多线程中可以选择Vector或者CopyOnWriteArrayList。 实现了Cloneable接口，即覆盖了函数clone( )，能被克隆。 实现java.io.Serializable接口，意味着ArrayList支持序列化，能通过序列化去传输。 直接用transient修饰数组。 12 //类的版本控制的序列号private static final long serialVersionUID = 8683452581122892189L; 12 transient Object[] elementData; //未设置从成私有属性，为了方便内部类访问 add()123456789101112131415161718192021222324252627282930313233343536373839404142434445public void add(int index, E element) { rangeCheckForAdd(index); ensureCapacityInternal(size + 1); //用来确保数组容量够 System.arraycopy(elementData, index, elementData, index + 1, size - index); elementData[index] = element; size++;}private void ensureExplicitCapacity(int minCapacity) { //记录修改次数 modCount++; // 避免溢出 if (minCapacity - elementData.length > 0) grow(minCapacity);}private void grow(int minCapacity) { int oldCapacity = elementData.length; //容量扩大1.5倍 int newCapacity = oldCapacity + (oldCapacity >> 1); //如果扩大1.5倍还是小，则直接替换成minCapacity if (newCapacity - minCapacity < 0) newCapacity = minCapacity; if (newCapacity - MAX_ARRAY_SIZE > 0) newCapacity = hugeCapacity(minCapacity); //minCapacity通常接近于size，所以这是一个优势: elementData = Arrays.copyOf(elementData, newCapacity);}private void fastRemove(int index) { //记录修改次数 modCount++; //计算需要移动的元素个数 int numMoved = size - index - 1; if (numMoved > 0) System.arraycopy(elementData, index+1, elementData, index, numMoved); //释放引用以便原对象被垃圾回收 elementData[--size] = null; } foreach编译器会把它转换成类似代码 1234Iterator it=intList.iterator();while(it.hasNext()){ sout(it.next());} jdk 1.7中实现 Iterable 接口，接口中要求实现Iterator方法。 1.8中，定义了一个抽象方法。 1public abstract Iterator iterator(); 1234567891011121314151617181920 //迭代器允许调用者使用良好的语义在迭代期间从基础集合中删除元素。代替了枚举接口Enumeration public interface Iterator { boolean hasNext(); E next(); //从基础集合中移除此迭代器返回的最后一个元素(可选操作)。此方法在每次调用{@link #next}时只能调用一次。如果在迭代过程中以调用此方法以外的任何方式修改了底层集合，则迭代器的行为是未指定的。 default void remove() { throw new UnsupportedOperationException("remove"); } //为每个剩余元素执行给定的操作，直到处理完所有元素或操作引发异常。 default void forEachRemaining(Consumer action) { Objects.requireNonNull(action); while (hasNext()) action.accept(next()); }} 其中Itr是一个成员内部类，实现了Iterator接口。 123456789101112131415161718192021222324private class Itr implements Iterator { int cursor; // index of next element to return int lastRet = -1; // index of last element returned; -1 if no such //表示期望的修改次数，与之前的外部类修改次数modcount进行比较，内部类可以访问外部类的实例变量，每次发生结构性变化，modcount就会增加，而每次迭代器操作，就会检查expectedModCount 和 modCount，这样就能检测出结构性变化。 int expectedModCount = modCount; Itr() {} public boolean hasNext() { return cursor != size; } @SuppressWarnings("unchecked") public E next() { checkForComodification(); int i = cursor; if (i >= size) throw new NoSuchElementException(); Object[] elementData = ArrayList.this.elementData; if (i >= elementData.length) throw new ConcurrentModificationException(); cursor = i + 1; return (E) elementData[lastRet = i]; } LinkedList modCount++同样也是为了记录修改次数，便于检测中间的结构性变化。 添加方法1234567891011void linkLast(E e) { final Node l = last; final Node newNode = new Node(l, e, null); last = newNode; if (l == null) first = newNode; else l.next = newNode; size++; modCount++; } 获取元素方法123456789101112131415Node node(int index) { // assert isElementIndex(index); if (index < (size >> 1)) { Node x = first; for (int i = 0; i < index; i++) x = x.next; return x; } else { Node x = last; for (int i = size - 1; i > index; i--) x = x.prev; return x; } } 若索引部分在前半部分，则从头结点开始查找，否则从尾结点开始查找。 1234567891011121314151617public int indexOf(Object o) { int index = 0; if (o == null) { for (Node x = first; x != null; x = x.next) { if (x.item == null) return index; index++; } } else { for (Node x = first; x != null; x = x.next) { if (o.equals(x.item)) return index; index++; } } return -1;} 插入新元素123456789101112void linkBefore(E e, Node succ) { // assert succ != null; final Node pred = succ.prev; final Node newNode = new Node(pred, e, succ); succ.prev = newNode; if (pred == null) first = newNode; else pred.next = newNode; size++; modCount++; } 步骤： 新建一个节点，先获得待插入节点的前驱。 1newNode = new Node(pred, e, succ); 后继的前驱指向新节点 1succ.prev = newNode; 前驱的后继指向新节点 1prev.next=newNode; 删除元素123456789101112131415161718192021222324252627 E unlink(Node x) { // assert x != null; final E element = x.item; //先获取 x 的后继节点 final Node next = x.next; //再获取 x 的前驱节点 final Node prev = x.prev;//若前驱节点为空，说明删除的是头结点，修改头结点为x的后继，若不为空，则令前驱节点的后继节点指向删除节点的后继节点，再将删除节点的前驱节点置为null。 if (prev == null) { first = next; } else { prev.next = next; x.prev = null; }//若后继节点为空，说明删除的是尾结点，修改尾结点为x的前驱，若不为空，则令后继节点的前驱节点指向删除节点的前驱节点，再将删除节点的后继节点置为null。 if (next == null) { last = prev; } else { next.prev = prev; x.next = null; } x.item = null; size--; modCount++; return element; } 删除 x 节点，则让 x 的前驱和后继节点直接连接起来， ArrayDeque基于数组实现的双端队列，相当于实现了一个循环数组。 123456789101112131415161718private static int calculateSize(int numElements) { int initialCapacity = MIN_INITIAL_CAPACITY; // Find the best power of two to hold elements. // Tests "]]></content>
      <categories>
        <category>基础</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>容器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[查缺补漏]]></title>
    <url>%2F2019%2F10%2F09%2F%E6%9F%A5%E7%BC%BA%E8%A1%A5%E6%BC%8F%2F</url>
    <content type="text"><![CDATA[计算机基础 平时所说的32位机器，就是能够同时处理字长为32位的电路信号。最左边表示正负，0表示正数，1表示负数。 负数的补码时反码加1，这样可以使减法运算可以使用加法器进行运算。 java基础 异或( ^ ): 相同则false , 不同则 true。 短路或 ( || ): 会短路，若前半段式子为true， 则后面式子不成立。 “ | ” ：是后面的式子依然会成立。 对于数组： 实际内容存储在堆上，而实际内容的地址空间在栈上。 按位与 &：都是 1 才是 1。 应用场景：获取网段值，IP地址与掩码255.255.255.0进行按位与（&）运算得到高24位，即为当前IP 的网段。 按位或 |：只要有 1 ，则为 1 。 getBytes( String str ) ： 获取字符串的二进制形式。 Arrays的方法： int binarySearch( long [ ] a,long key) 查找一个数 int[ ] copyOf( int [ ], int length) 数组复制 引用型变量存储在栈上， 保存的是实际内容的地址，而实际内容保存在堆山。 静态导入： static import 直接导入静态方法和成员 单精度占4字节，双精度占8字节 sleep函数的运用sleep 作为将当前线程挂起指定的时间 假设现在是 2008-4-7 12:00:00.000，如果我调用一下 Thread.Sleep(1000) ，在 2008-4-7 12:00:01.000 的时候，这个线程会不会被唤醒？答案是：不一定。因为你只是告诉操作系统：在未来的1000毫秒内我不想再参与到CPU竞争。那么1000毫秒过去之后，这时候也许另外一个线程正在使用CPU，那么这时候操作系统是不会重新分配CPU的，直到那个线程挂起或结束；况且，即使这个时候恰巧轮到操作系统进行CPU 分配，那么当前线程也不一定就是总优先级最高的那个，CPU还是可能被其他线程抢占去。 某人的代码中用了一句看似莫明其妙的话：Thread.Sleep(0) 。既然是 Sleep 0 毫秒，那么他跟去掉这句代码相比，有啥区别么？Thread.Sleep(0)的作用，就是“触发操作系统立刻重新进行一次CPU竞争”。竞争的结果也许是当前线程仍然获得CPU控制权，也许会换成别的线程获得CPU控制权。这也是我们在大循环里面经常会写一句Thread.Sleep(0) ，因为这样就给了其他线程比如Paint线程获得CPU控制权的权力，这样界面就不会假死在那里。 为什么需要两个survivor区先来看一张图，假设没有Survivor区，Eden区每进行一次Minor GC，存活的对象就会被送到老年代。老年代很快被填满，触发Major GC（因为Major GC一般伴随着Minor GC，也可以看做触发了Full GC）。老年代的内存空间远大于新生代，进行一次Full GC消耗的时间比Minor GC长得多。频发的Full GC消耗的时间是非常可观的，这一点会影响大型程序的执行和响应速度，更不要说某些连接会因为超时发生连接错误了。 Survivor的存在意义，就是减少被送到老年代的对象，进而减少Full GC的发生，Survivor的预筛选保证，只有经历16次Minor GC还能在新生代中存活的对象，才会被送到老年代。 假设只设置一个Survivor区，当刚刚新建的对象在Eden中，一旦Eden满了，触发一次Minor GC，Eden中的存活对象就会被移动到Survivor区。这样继续循环下去，下一次Eden满了的时候，问题来了，此时进行Minor GC，Eden和Survivor各有一些存活对象，如果此时把Eden区的存活对象硬放到Survivor区，很明显这两部分对象所占有的内存是不连续的，也就导致了内存碎片化。堆空间被散布的对象占据不连续的内存，最直接的结果就是，堆中没有足够大的连续内存空间，接下去如果程序需要给一个内存需求很大的对象分配内存 设置两个Survivor区上述机制最大的好处就是，整个过程中，永远有一个survivor space是空的，另一个非空的survivor space无碎片。 至于Survivor不分更多的区域，显然，若Survivor区再细分下去，每一块的空间就会比较小，很容易导致Survivor区满，两块Survivor区应该是经过权衡之后的最佳方案。 surviror的from区可以创建对象吗在eden区创建，对象总在eden区出生，surviror的from区保存当前的幸存对象，to区则为空。 一次GC过程之后 eden区的对象+fron存储的对象 ——>复制到to区 清空eden区的对象+fron存储的对象 颠倒from区和to区的逻辑 线程池执行任务时，如何在某一个任务执行完毕返回结果，就立即停止线程池其他任务 signal 主线程CAS自旋+shutdownnow 设置一个容量为1的countdownlatch，然后countdownlatch返回后直接shutdownnow 用一个对象承载每个子任务的thread，然后一个子任务完成后，处理线程中断 CompletableFuture 的cancel()操作 秒杀扩展JVM（并发导致快速GC） +横向扩展+ 分布式压测 Volatile一个线程在读取使用volatile修饰的变量时，会将该线程中所有使用的变量从主内存中读取。 详细解释：JVM会尽力保证从主内存同步数据，当不加volatile时，看线程情况，会尽力同步主内存的额数据到线程内存中。 volatile修饰数组，其实是数组的地址是线程可见的，实际上数组内元素看上去”线程内可见”，是因为每次获取元素时数组都是从主内存中获取地址信息，再根据index得到元素。 AtomicIntegerArray 和AtomicReference对元素实现了volatile的读写。 sleep会增加同步主内存数据的机会。 当读一个volatile变量时，JMM会把该线程对应的本地内存置为无效，强制走主内存。 高并发场景针对字典树字典树固有的代码块 123456789char[] letter=word.charArray();for(int i=0;i { img.remove(); }); document.body.appendChild(img); });]]></content>
      <categories>
        <category>基础知识</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>虚拟机</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[秒杀模块-基础知识]]></title>
    <url>%2F2019%2F10%2F09%2F%E7%A7%92%E6%9D%80%E6%A8%A1%E5%9D%97-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%2F</url>
    <content type="text"><![CDATA[用到的技术栈，springboot，MyBatis，Redis,Druid,RabbitMq 实现分布式session 秒杀逻辑 添加spring-boot依赖和模板引擎依赖123456789101112131415 org.springframework.boot spring-boot-starter-parent 2.1.5.RELEASE org.springframework.boot spring-boot-starter-web org.springframework.boot spring-boot-starter-thymeleaf 2.0.4.RELEASE 在属性文件中添加关于模板引擎的配置，设置前缀和后缀。 12spring.thymeleaf.prefix=classpath:/templates/spring.thymeleaf.suffix=.html 添加Mysql依赖和Druid依赖在pom.xml中修改 1234567891011121314151617 org.mybatis.spring.boot mybatis-spring-boot-starter 1.3.2 mysql mysql-connector-java 8.0.13 com.alibaba druid 1.1.10 属性文件中添加 12345678910111213mybatis.type-aliases-package=com.hzc.secKill.Domain//下划线转成xml驼峰命名法mybatis.configuration.map-underscore-to-camel-case=truemybatis.configuration.default-fetch-size=100mybatis.configuration.default-statement-timeout=3000//配置文件扫描，接口类与xml文件放在一起mybatis.mapper-locations=classpath:com/hzc/secKill/DAO/*.xml//数据库名称为miaoshaspring.datasource.url=jdbc:mysql://localhost:3306/miaosha?useUnicode=true&characterEncoding=utf8&useSSL=false&serverTimezone=Asia/Shanghai&allowPublicKeyRetrieval=truespring.datasource.username=rootspring.datasource.password=xxxxspring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver 注意： 12345678@Mapper@Repositorypublic interface UserDAO { //@Param("id") 作为变量 @Select("select * from user where id = #{id}") public User getById(@Param("id") int id);} 配置redis在.conf文件中修改bind 0.0.0.0 因为之后要设置成分布式 daemonize yes允许后台运行 requirepass 123456 设置密码 1234redis-server ./redis.conf//查看进程ps -ef | grep redisredis-cli 1234567891011 redis.clients jedis 2.9.0 com.alibaba fastjson 1.2.47 新建redis文件夹，则添加redisconfig.class，使用@Component注解进行配置文件的扫描。 12345678910111213141516171819202122@Component@ConfigurationProperties(prefix = "redis")public class RedisConfig { private String host; private int port; public String getHost() { return host; } public void setHost(String host) { this.host = host; } public int getPort() { return port; } public void setPort(int port) { this.port = port; }} 修改下本地的ip地址，以及配置好密码 123spring.datasource.url=jdbc:mysql://127.0.0.1:3306/miaosha?useUnicode=true&characterEncoding=utf-8&allowMultiQueries=true&useSSL=falsespring.datasource.username=rootspring.datasource.password=admin 试试分布式压测 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <categories>
        <category>项目</category>
      </categories>
      <tags>
        <tag>springboot</tag>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IM通信系统 (2)]]></title>
    <url>%2F2019%2F10%2F09%2FIM%E9%80%9A%E4%BF%A1%E7%B3%BB%E7%BB%9F%20%20%20%20%20(2)%2F</url>
    <content type="text"><![CDATA[客户端的启动流程 初始化客户端，设置相应参数，配置线程模型，IO模型以及数据连接读写逻辑 connect（）方法是异步调用的，借助异步回调机制来实现指数退避重连逻辑 相对于服务端，客户端不需要调用childhandler( )方法，客户端不需要监听新连接的接入。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172import io.netty.bootstrap.Bootstrap;import io.netty.buffer.ByteBuf;import io.netty.channel.Channel;import io.netty.channel.ChannelFuture;import io.netty.channel.ChannelInitializer;import io.netty.channel.ChannelOption;import io.netty.channel.nio.NioEventLoopGroup;import io.netty.channel.socket.SocketChannel;import io.netty.channel.socket.nio.NioSocketChannel;import the.flash.protocol.PacketCodeC;import the.flash.protocol.request.MessageRequestPacket;import the.flash.util.LoginUtil;import java.util.Date;import java.util.Scanner;import java.util.concurrent.TimeUnit;public class NettyClient { private static final int MAX_RETRY = 5; private static final String HOST = "127.0.0.1"; private static final int PORT = 8000; public static void main(String[] args) { NioEventLoopGroup workerGroup = new NioEventLoopGroup(); //客户端启动的引导类,对应Bio中的socket,负责启动客户端并且连接服务端 Bootstrap bootstrap = new Bootstrap(); bootstrap //同样的，指定线程模型 .group(workerGroup) //指定IO模型 .channel(NioSocketChannel.class) //表示连接超时的时间 .option(ChannelOption.CONNECT_TIMEOUT_MILLIS, 5000) //这里的参数和服务端配置的参数一致 .option(ChannelOption.SO_KEEPALIVE, true) .option(ChannelOption.TCP_NODELAY, true) //给引导类指定一个handler，定义业务处理逻辑 .handler(new ChannelInitializer() { @Override public void initChannel(SocketChannel ch) { ch.pipeline().addLast(new ClientHandler()); } }); connect(bootstrap, HOST, PORT, MAX_RETRY); }//如果网络环境差，则会使用失败重连 private static void connect(Bootstrap bootstrap, String host, int port, int retry) { //bootsrap的conntect方法中有两个参数，第一个参数是IP，第二个参数是端口号 bootstrap.connect(host, port).addListener(future -> { if (future.isSuccess()) { System.out.println(new Date() + ": 连接成功，启动控制台线程……"); Channel channel = ((ChannelFuture) future).channel(); startConsoleThread(channel); } else if (retry == 0) { System.err.println("重试次数已用完，放弃连接！"); } else { // 第几次重连 int order = (MAX_RETRY - retry) + 1; // 本次重连的间隔 int delay = 1 < order; connect(bootstrap, host, port, retry - 1), delay, TimeUnit .SECONDS); } }); }} 如果在微服务的体系下，客户端不需要约定好端口，都是服务端启动并注册到微服务注册中心，注册host和port，客户端从注册中心获取服务端的信息即可。 此处使用定时任务逻辑，不使用sleep的原因： sleep（）需要处理Interrupted异常 可以交给专门的调度线程去做，主线程不会休眠。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <categories>
        <category>项目</category>
      </categories>
      <tags>
        <tag>netty</tag>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IM通信系统 （1）]]></title>
    <url>%2F2019%2F10%2F09%2FIM%E9%80%9A%E4%BF%A1%E7%B3%BB%E7%BB%9F%20%20%20%20%20(1)%2F</url>
    <content type="text"><![CDATA[服务端的启动流程 初始化服务端，设置相应参数，配置线程模型，IO模型以及数据连接读写逻辑 实现自动绑定端口逻辑 不仅需要监听本地端口，而且一直与客户端的连接进行交互。有两种类型的channel 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758import io.netty.bootstrap.ServerBootstrap;import io.netty.channel.ChannelInitializer;import io.netty.channel.ChannelOption;import io.netty.channel.nio.NioEventLoopGroup;import io.netty.channel.socket.nio.NioServerSocketChannel;import io.netty.channel.socket.nio.NioSocketChannel;import java.util.Date;public class NettyServer { private static final int PORT = 8000; public static void main(String[] args) { //表示监听端口，accept新连接的线程组 //参数中不需要设置成1，nio线程本身是懒启动 NioEventLoopGroup boosGroup = new NioEventLoopGroup(); //表示处理每一条连接的数据读写的线程组 NioEventLoopGroup workerGroup = new NioEventLoopGroup(); //服务端启动的引导类，可以对应Bio中的serversocket final ServerBootstrap serverBootstrap = new ServerBootstrap(); serverBootstrap //给引导类配置两大线程组 .group(boosGroup, workerGroup) //配置IO模型，指定为NIO .channel(NioServerSocketChannel.class) //给服务端的channel设置一些属性，表示系统临时存放已完成三次握手队列的最大长度 .option(ChannelOption.SO_BACKLOG, 1024) //表示开启TCP底层心跳机制 .childOption(ChannelOption.SO_KEEPALIVE, true) //表示开启Nagle方法，需要减少发送次数，以及减少网络交互，就开启 .childOption(ChannelOption.TCP_NODELAY, true) //给引导类创建一个ChannelInitializer，定义后序每条数据的连接读写 .childHandler(new ChannelInitializer() { protected void initChannel(NioSocketChannel ch) { ch.pipeline().addLast(new ServerHandler()); } });//原来的是serverfBootstrap.bind(8000)，这个方法是一个异步的方法，返回的是一个ChannelFuture, //可以给这个ChannelFuture添加一个监听器，在方法片段里添加判断端口是否绑定成功 bind(serverBootstrap, PORT); }//实现自动绑定端口逻辑 private static void bind(final ServerBootstrap serverBootstrap, final int port) { //lambda表达式 serverBootstrap.bind(port).addListener(future -> { if (future.isSuccess()) { System.out.println(new Date() + ": 端口[" + port + "]绑定成功!"); } else { System.err.println("端口[" + port + "]绑定失败!"); //不用lambda表达式的话，还要重新调用自身方法，并且将端口号+1 bind(serverBootstrap, port+1); } }); }} document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <categories>
        <category>项目</category>
      </categories>
      <tags>
        <tag>netty</tag>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法思路汇总]]></title>
    <url>%2F2019%2F10%2F08%2F%E7%AE%97%E6%B3%95%E6%80%9D%E8%B7%AF%E6%B1%87%E6%80%BB%2F</url>
    <content type="text"><![CDATA[数组相关（双指针，对撞指针）2 sum注意的地方在于边放入元素，边进行元素是否在map中的判断。 12345678910for (int i = 0; i < nums.length; i++) { // 判断是否有匹配的 Integer j = numIndexMap.get(target - nums[i]); if (j != null) { return new int[]{i, j}; } // 添加到 numIndexMap 中 numIndexMap.put(nums[i], i);} 2 sum 改进版给定一个已按照升序排列 的有序数组，找到两个数使得它们相加之和等于目标数。 使用对撞指针思想，当和大于预定值，右指针向左移动，同理，左指针向右移动。 123456789101112int left = 0, right = numbers.length - 1; while (left < right) { int sum = numbers[left] + numbers[right]; if (sum == target) { return new int[]{left + 1, right + 1}; } if (sum > target) { right--; } else { left++； } } 设计getMin操作的栈push()方法：在压入操作时，判断stackMin是否为空，空则压入，如果不为空，与getMin()方法得到的值进行比较，小则压入。 stackData()一直压入。 getMin()方法stackMin()不为空，则直接返回peek()。 pop()方法stackData栈Pop出一个值，和stackMin的peek()值比较，等于则一起弹出，不等于则返回stackData栈Pop出的值。 两个栈组成的队列关键在于一个栈作为压入栈，记为stack1，一个栈作为弹出栈，记为stack2，每次需要先判断stack2是否为空，只有当stack2为空时，才能将stack1中的所有元素压入stack2中。 12345if(stack2.isEmpty()){ while(!stack1.isEmpty()){ stack2.push(stack1.pop()); }} 递归操作逆序一个栈先将栈stack的栈底元素返回并移除,然后依次再压入 在将栈的栈底元素返回并移除时，其中return result,最终的出栈元素被返回，没能被压入栈，此时的return更像是递归到底之后再向上回溯的过程。 1234567if(stack.isEmpty()){ return result;}else{ int last=递归调用; stack.push(result); return last;} 一个栈实现实现另一个栈的逆序其中如果是按照从顶到底的顺序是从大到小的顺序，可以先申请一个辅助栈，栈底是最大的元素，如果要放入的元素比辅助栈栈顶的元素大，就把辅助栈元素依次弹出，直到放入的元素此时小于栈顶元素，将元素压入。 最后再将元素从辅助栈中弹出，再压入到原来的栈。 生成窗口最大值数组使用双端队列，遍历数组元素，如果队列不为空，且队列的末尾元素小于当前数组的值，则依次弹出队列的末尾元素，直至末尾元素大于数组值。记录数组元素的索引值，当队列头部的值==数组当前索引 - 窗口当前大小时，将队列头部的值弹出。 当数组当前索引 >= 窗口当前大小-1时，则将这些窗口最大值记录下来，即当前队列的头部元素的值。 单调栈什么是单调栈？单调栈分为单调递增栈和单调递减栈，单调递增栈即栈内元素保持单调递增的栈，同理单调递减栈即栈内元素保持单调递减的栈，跟单调队列差不多，但是只用到它的一端。 单调递增栈123456for(int i = 0; i < T.size(); i++){ while(! stk.empty() && stk.top() > T[i]){ stk.pop(); } stk.push(A[i]);} 单调递减栈123456for(int i = T.size() - 1; i >= 0; i--){ while(! stk.empty() && T[i] >= stk.top()){ stk.pop(); } stk.push(i);} 单调栈的作用：可以以 O(1) 的时间复杂度得知某个位置左右两侧比他大（或小）的数的位置，当你需要高效率获取某个位置左右两侧比他大（或小）的数的位置的的时候就可以用到单调栈。 求解数组中元素右边第一个比它小的元素的下标，从前往后，构造单调递增栈； 求解数组中元素右边第一个比它大的元素的下标，从前往后，构造单调递减栈； 求解数组中元素左边第一个比它小的元素的下标，从后往前，构造单调递减栈； 求解数组中元素左边第一个比它小的元素的下标，从后往前，构造单调递增栈。 打印两个有序链表的公共部分注意在判断两个链表的值相同时，要继续遍历链表 1234if(node1.val==node2.val){ node1=node1.next; node2=node2.next;} 单链表和双链表删除倒数第K个节点单链表删除 快慢指针法 可以先让fast指针先走k步，再让fast和slow一起继续遍历，直至fast为空。需要设立虚拟头结点dummyhead 先从头结点开始遍历链表，其中K值保持 K– ，遍历到链表尾部。若K小于0，再进行++K，当K等于0时，移动到的节点是待删除节点的前一个节点。若K=0,则直接返回头结点的下一个节点。 1234567if(K= 4) { if (pos == s.length()) ans.add(String.join(".", cur)); return; } // 分割得到ip地址的一段后，下一段只能在长度1-3范围内选择 for (int i = 1; i s.length()) break; String segment = s.substring(pos, pos+i); // 剪枝条件：不能以0开头，不能大于255 if (segment.startsWith("0") && segment.length() > 1 || (i == 3 && Integer.parseInt(segment) > 255)) continue; cur.add(segment); // 注意此处传的参数 backtracking(s, pos+i, cur, ans); cur.remove(cur.size()-1); } } public List restoreIpAddresses(String s) { List ans = new ArrayList(); backtracking(s, 0, new ArrayList(), ans); return ans; } 123456789101112131415161718public List letterCombinations(String digits) { if(digits.length()!=0){ dfs("", digits); } return result; } private void dfs(String combination, String digits) { if (digits.length() == 0) { result.add(combination); } else { String digit = digits.substring(0, 1); for (int i = 0; i < map1.get(digit).length(); i++) { String letter = map1.get(digit).substring(i, i + 1); dfs(combination + letter, digits.substring(1)); } } } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <categories>
        <category>算法与数据结构</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>最优解</tag>
        <tag>程序设计</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关键字]]></title>
    <url>%2F2019%2F10%2F08%2F%E5%85%B3%E9%94%AE%E5%AD%97%2F</url>
    <content type="text"><![CDATA[Staticstatic方法内部的变量是没有线程安全问题的，因为数据运行在栈里，线程是隔离开的。 static修饰的类变量，方法，代码块以及内部类，都属于类成员，不属于实例成员。 对static修饰的类变量，方法，代码块初始化顺序： 父类的静态变量和代码块比子类优先初始化； 其中静态变量和代码块在main方法之前便已经初始化。 在main方法之后父类构造器和子类构造器才开始初始化。 注意一种特殊情况： static修饰对象，注意其构造器内的语句先执行。 final final修饰的类，无法继承 修饰的方法，无法被覆写 修饰的变量，声明时必须初始化，也不能修改其内存地址 要举String的例子 try catch finally如果在try和catch中都遇到了异常，代码执行顺序是try -> catch -> finally 当finally执行后，再抛出异常 最终抛出的是catch的异常。 default一般使用在接口上，对于该接口，子类无须强制实现，但自己必须有默认实现。 比如集合中的Map利用default关键字新增各种方法。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <categories>
        <category>基础知识</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[源码系列]]></title>
    <url>%2F2019%2F10%2F08%2F%E6%BA%90%E7%A0%81%E7%B3%BB%E5%88%97%20%20--%20%20JDK%E7%9B%B8%E5%85%B3%2F</url>
    <content type="text"><![CDATA[String1234public final class String implements java.io.Serializable, Comparable, CharSequence { /** The value is used for character storage. */ private final char value[];} String 不可变的原因 String类被final修饰，不能被继承 保存的是一个char型数组，而且是private修饰 但可以通过反射进行修改。 123456String str="hello";Class clazz=Class.forName("java.lang.String");Field field=clazz.getDeclaredField("value");field.setAccessible(true);char[] value=(char[]) field.get(str); String.replace其中String.replace(char,char)要比String.replaceAll(String,String)性能好，字符在200左右就能看出差异。但relpaceAll()方法支持正则表达式，会对参数进行解析。 public String substring(int beginIndex)方法结束位置为文本末尾。 12this.value = Arrays.copyOfRange(value, offset, offset+count)//从字符数组进行一段范围的拷贝 重写equals方法1234567891011121314151617181920212223public boolean equals(Object anObject) { //先判断内存地址是否相同 if (this == anObject) { return true; } //判断比较的对象是否是String类型 if (anObject instanceof String) { String anotherString = (String)anObject; int n = value.length; if (n == anotherString.value.length) { char v1[] = value; char v2[] = anotherString.value; int i = 0; while (n-- != 0) { if (v1[i] != v2[i]) return false; i++; } return true; } } return false; } Longbyte 1字节 short 2字节 int 4字节 long 8字节 switch中不能使用long型数据，因为跳转表值的存储空间一般为32位，很难容纳下long。而String可以通过hashcode()方法转换为整数。 缓存内部实现了一种缓存机制，缓存了从-128到127内的所有long值。 1234567891011 private static class LongCache { private LongCache(){} static final Long cache[] = new Long[-(-128) + 127 + 1];//当容器初始化时，static修饰的代码块自动进行随之加载 static { //缓存long值。 for(int i = 0; i < cache.length; i++) cache[i] = new Long(i - 128); } } 工具类通用特征 构造器必须私有，使用时无须初始化 工具类的工具方法必须被static和final来修饰，保证方法不可变 Arrays.binarySearch() 用于快速从数组中查找出对应的值 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <categories>
        <category>底层源码</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java中的常量池种种]]></title>
    <url>%2F2019%2F09%2F28%2Fjava%E4%B8%AD%E7%9A%84%E5%B8%B8%E9%87%8F%E6%B1%A0%E7%A7%8D%E7%A7%8D%2F</url>
    <content type="text"><![CDATA[常量池的划分 Class 文件常量池 运行时常量池 字符串常量池 Class 文件常量池Class 文件常量池指的是编译生成的 class 字节码文件，其结构中有一项是常量池，用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后进入方法区的运行时常量池中存放。 什么是字面量和符号引用？字面量指字符串字面量和声明为 final 的（基本数据类型）常量值，这些字符串字面量除了类中所有双引号括起来的字符串(包括方法体内的)，还包括所有用到的类名、方法的名字和这些类与方法的字符串描述、字段(成员变量)的名称和描述符；方法内的常量值由栈分配，所以并不算是字面量。符号引用指指向 UTF-8 表中向这些字面量的引用，包括类和接口的全限定名(包括包路径的完整名)、字段的名称和描述符、方法的名称和描述符。只不过是以一组符号来描述所引用的目标，和内存并无关，所以称为符号引用，直接指向内存中某一地址的引用称为直接引用。 运行时常量池运行时常量池是方法区的一部分，是一块内存区域。Class 文件常量池将在类加载后进入方法区的运行时常量池中存放。 一个类加载到 JVM 中后对应一个运行时常量池，运行时常量池相对于 Class 文件常量池来说具备动态性，Class 文件常量只是一个静态存储结构，里面的引用都是符号引用。而运行时常量池可以在运行期间将符号引用解析为直接引用。 运行时常量池就是用来索引和查找字段和方法名称和描述符的。给定任意一个方法或字段的索引，通过这个索引最终可得到该方法或字段所属的类型信息和名称及描述符信息。 字符串常量池（Interned Strings）在 JDK1.6（含）之前也是方法区的一部分，并且其中存放的是字符串的对象。在 JDK1.7（含）之后，是在堆内存之中，存储的是字符串对象的引用，字符串实例是在堆中。 也就是说先在类加载完成，经过验证，准备阶段在堆中生成字符串对象实例，然后将对象实例的引用值存到字符串常量池中。 字符串常量池是全局的，JVM 中独此一份，即StringTable类，是一个哈希表，因此也称为全局字符串常量池。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <categories>
        <category>基础知识</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[并发编程-基础]]></title>
    <url>%2F2019%2F09%2F25%2F%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[概念进程与线程进程是资源分配的基本单位，线程是独立调度的基本单位，CPU调度和分派的基本单位。 操作系统在分配资源时候是把资源分配给进程的，但是 CPU 资源就比较特殊，它是分派到线程的，因为真正要占用 CPU 运行的是线程，所以也说线程是 CPU 分配的基本单位。 同步和异步同步： 同步方法调用一旦开始，调用者必须等待调用方法返回，才能继续后面的行为。 异步：只需要调用方法，便会立即返回，可以继续后续的操作。 并发和并行：并发：侧重于任务的交替执行，多个任务是串行执行的。 并行：真正意义上的同时执行。 当只有一个CPU时，一个CPU一次只能执行一条指令，这种情况下多进程与多线程是并发的，而不是并行的。 只有多核CPU才会出现并行情况。 临界区表示一种公共资源或者共享数据，可以被多个线程使用，但每次使用时只能有一个线程去使用它。 阻塞与非阻塞形容多个线程之间的影响。 阻塞：其中假设一个线程占用了临界区资源 ，其他需要该资源的线程就需要一直等待该线程释放资源。 非阻塞：没有一个线程可以妨碍其他线程的工作，所有线程都会尝试向前执行。 死锁、饥饿、活锁饥饿： 某一个线程因为种种原因始终无法获得需要的资源，导致一直无法执行。 比如优先级太低 或者 某一个线程始终占用着关键资源不放，导致其他线程无法执行。 活锁： 线程互相谦让，主动将资源释放给别人使用，资源便会在两个线程之间跳动，则没有一个线程拿到资源。 并发级别：阻塞：如果使用的和其他重入锁，得到的就是一个阻塞的队列。 无饥饿：锁是公平的，遵循着先来先到的原则，不管新来的线程优先级多高，都要乖乖排队。 无障碍最弱的非阻塞调度，是一种乐观的控制策略，一旦发现修改共享数据冲突，则进行回滚操作。 无锁并行也是无障碍的，但不同的是无锁的并发保证必然有一个线程能够在有限步中完成操作离开临界区。 无等待 在无锁的基础上，要求全部线程都在有限步内完成。 并行定律Amdahl定律： 定义了串行化系统并行化后的加速比的计算公式和理论上限。强调当串行比例一定时，加速比有上限，不管堆叠多少个CPU，都不能突破上限。 Gustafson定律：如果可被并行化的代码比重足够多，则加速比随着CPU数量呈线性增长。线程创建与运行 Java 中有三种线程创建方法，分别为实现 Runnable 接口的run方法、继承 Thread 类并重写 run 方法、使用 FutureTask 方式。 实现继承 Thread 方法 123456789101112131415161718public class ThreadTest { //继承Thread类并重写run方法 public static class MyThread extends Thread { @Override public void run() { System.out.println("I am a child thread"); } } public static void main(String[] args) { // 创建线程 MyThread thread = new MyThread(); // 启动线程 thread.start(); }} MyThread 类继承了 Thread 类，并重写了 run 方法，然后调用了线程的 start 方法启动了线程，当创建完 thread 对象后该线程并没有被启动执行。当调用了 start 方法后才是真正启动了线程。其实当调用了 start 方法后线程并没有马上执行而是处于就绪状态，这个就绪状态是指该线程已经获取了除 CPU 资源外的其它资源，等获取 CPU 资源后才会真正处于运行状态。 当 run 方法执行完毕，该线程就处于终止状态了。使用继承方式好处是 run 方法内获取当前线程直接使用 this 就可以，无须使用 Thread.currentThread() 方法，不好的地方是 Java 不支持多继承，如果继承了 Thread 类那么就不能再继承其它类，另外任务与代码没有分离，当多个线程执行一样的任务时候需要多份任务代码，而 Runnable 则没有这个限制。 实现 Runnable 接口的 run 方法 123456789101112public static class RunableTask implements Runnable{ @Override public void run() { System.out.println("I am a child thread"); } }public static void main(String[] args) throws InterruptedException{ RunableTask task = new RunableTask(); new Thread(task).start(); new Thread(task).start();} 如上面代码，两个线程公用一个 task 代码逻辑，需要的话 RunableTask 可以添加参数进行任务区分，另外 RunableTask 可以继承其他类，但是上面两种方法都有一个缺点就是任务没有返回值。 实现 FutureTask 123456789101112131415161718192021222324//创任务类，类似Runablepublic static class CallerTask implements Callable{ @Override public String call() throws Exception { return "hello"; } } public static void main(String[] args) throws InterruptedException { // 创建异步任务 FutureTask futureTask = new FutureTask(new CallerTask()); //启动线程 new Thread(futureTask).start(); try { //等待任务执行完毕，并返回结果 String result = futureTask.get(); System.out.println(result); } catch (ExecutionException e) { e.printStackTrace(); }} 哪些指令不能重排：（Happen-Before原则） 程序顺序执行：一个线程内保证语义的串行性 volatile原则： volatile变量的写操作必然要早于读操作 锁规则： lock要发生在unlock之前 传递性： A先于B，B先于C，则A先于C start（）方法早于先于它的任何一个工作 线程所有操作先于Thread.join( ) interrupt( )中断操作先于被中断线程的代码 对象的构造函数执行，结束均先于finalize（ ）方法 不使用多进程而使用多线程，是因为线程切换和调度的成本远远小于进程。 线程状态：查看JDK源码，发现其中线程在枚举类中有6个状态，NEW表示刚刚创建的线程，等待start()方法执行时，则处于RUNNABLE状态，表示线程所需的一切资源已经准备好了。 若执行过程中遇到了锁，则进入BLOCKED状态。 WAITING：会进入一个无时间限制的等待 TIMED_WAITING: 会进入一个有时间限制的等待 调用start()和调用run()方法的区别：其中调用run( )方法，只会在当前线程中串行执行run()中的代码。 线程中断1234public boolean Thread.isInterrupted() //判断线程是否被中断public void Thread.interrupted() //中断线程public static boolean Thread.isInterrupted()//静态方法，判断线程是否被中断，并清除当前线程的中断标志位。 例112345678910111213141516171819202122232425package com.thread.test1;public class Test_Interrupt { public static void main(String[] args) throws InterruptedException { Thread t1=new Thread(new Runnable() { @Override public void run() { while(true) { //判断是否被中断，如果只有t1.interrupt();则无法中断线程。需要添加标记变量。 if(Thread.currentThread().isInterrupted()) { System.out.println("Interrupted"); break; } } } }); t1.start(); Thread.sleep(200); t1.interrupt(); }} 例2123456789101112131415161718192021222324252627282930313233package com.thread.test1;public class Test_Interrupt { public static void main(String[] args) throws InterruptedException { Thread t1=new Thread(new Runnable() { @Override public void run() { while(true) { if(Thread.currentThread().isInterrupted()) { System.out.println("Interrupted"); break; } try { Thread.sleep(200); } catch (InterruptedException e) { System.out.println("Interrupt when sleep"); //设置中断，因为sleep方法由于中断而抛出异常，此时会清除中断标记，若不加处理，则下一次循环开始时，则无法捕获这个中断，故需要再次设置。 Thread.currentThread().interrupt(); } Thread.yield(); } } }); t1.start(); Thread.sleep(200); t1.interrupt(); }} 线程等待和通知Object对象必须包含在对应的sychronized语句中，无论是wait( )和notify( )都需要首先获得目标对象的一个监视器。若未事先获取到该对象的监视器锁，则调用 wait() 方法时候线程会抛出 IllegalMonitorStateException 异常。 当一个线程调用一个共享对象的 wait() 方法时候，调用线程会被阻塞挂起，直到下面几个情况之一发生才返回： 其它线程调用了该共享对象的 notify() 或者 notifyAll() 方法； 其它线程调用了该线程的 interrupt() 方法设置了该线程的中断标志，该线程会抛出 InterruptedException 异常返回。 虚假唤醒一个线程可以从挂起状态变为可以运行状态（也就是被唤醒）即使该线程没有被其它线程调用 notify()，notifyAll() 进行通知，或者被中断，或者等待超时。 为了防止虚假唤醒，需要不停的去测试该线程被唤醒的条件是否满足，不满足则继续等待，也就是说在一个循环中去调用 wait() 方法进行防范，退出循环的条件是条件满足了唤醒该线程。 12345synchronized (obj) { while (条件不满足){ obj.wait(); }} 等待线程执行终止的 join 方法三个窗口同步卖票使用显式锁 123456789101112131415161718192021222324252627282930313233343536373839package com.thread.test1;import java.util.concurrent.locks.Lock;import java.util.concurrent.locks.ReentrantLock;public class TestLock { public static void main(String[] args) { Ticket ticket=new Ticket(); // TODO Auto-generated method stub new Thread(ticket,"窗口1").start(); new Thread(ticket,"窗口2").start(); new Thread(ticket,"窗口3").start(); }}class Ticket implements Runnable{ private int ticket=100; private Lock lock=new ReentrantLock(); @Override public void run() { while(ticket>0) { lock.lock(); try { if(ticket>0) { try { Thread.sleep(200); } catch (InterruptedException e) { // TODO Auto-generated catch block e.printStackTrace(); } System.out.println(Thread.currentThread().getName()+ ":"+--ticket); } }finally { lock.unlock(); } } }} 模拟CAS算法12345678910111213141516171819202122232425262728293031323334353637383940414243package com.thread.test1;public class TestCompareAndSwap { public static void main(String[] args) { // TODO Auto-generated method stub final ComapareAndSwap casAndSwap=new ComapareAndSwap(); for(int i=0;i { img.remove(); }); document.body.appendChild(img); });]]></content>
      <categories>
        <category>并发编程</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[生产者消费者]]></title>
    <url>%2F2019%2F09%2F25%2F%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%2F</url>
    <content type="text"><![CDATA[生产者12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849import java.util.Random;import java.util.Vector;import java.util.concurrent.atomic.AtomicInteger;public class Producer implements Runnable { //使用volatile标志是否需要可见性，方便提供给stop()方法 private volatile boolean needProduce=true; //定义缓冲区 private final Vector sharequeue; //定义容量 private final int Size; //static修饰，既能计数，又能保证是线程安全的 private static AtomicInteger count=new AtomicInteger(); public Producer(Vector vector,int Size){ this.Size=Size; this.sharequeue=vector; } @Override public void run() { int data; Random random=new Random(); System.out.println("start product id= "+Thread.currentThread().getId()); try { while (needProduce){ //模拟延迟 Thread.sleep(random.nextInt(1000)); //当缓冲区大小达到最大容量，便阻塞 while (sharequeue.size()==Size){ synchronized (sharequeue){ System.out.println("Queue is full,produer "+Thread.currentThread().getId()+"is waiting "+sharequeue.size()); sharequeue.wait(); } } synchronized (sharequeue){ data=count.incrementAndGet(); sharequeue.add(data); System.out.println("create data: "+data+",size: "+sharequeue.size()); sharequeue.notifyAll(); } } }catch (InterruptedException e){ e.printStackTrace(); Thread.currentThread().interrupt(); } } public void stop(){ needProduce=false; }} 使用while循环是为了避免虚假唤醒。 消费者12345678910111213141516171819202122232425262728293031323334import java.util.Random;import java.util.Vector;public class Consumer implements Runnable { private final Vector sharequeue; public Consumer(Vector sharequeue) { this.sharequeue = sharequeue; } @Override public void run() { Random random = new Random(); System.out.println("start consumer id= " + Thread.currentThread().getId()); try { while (true) { Thread.sleep(random.nextInt(1000)); while (sharequeue.isEmpty()) { synchronized (sharequeue) { System.out.println("Queue is empty: ,consumer" + Thread.currentThread().getId() + "is running,size=" + sharequeue.size()); sharequeue.wait(); } } synchronized (sharequeue) { System.out.println("consumer consume data: " + sharequeue.remove(0) + ",size: " + sharequeue.size()); sharequeue.notifyAll(); } } } catch (InterruptedException e) { e.printStackTrace(); Thread.currentThread().interrupt(); } }} 主线程1234567891011121314151617181920212223242526272829303132import java.util.Vector;import java.util.concurrent.Executor;import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;public class Test { public static void main(String[] args) throws InterruptedException{ Vector vector=new Vector(); int size=4; ExecutorService executorService= Executors.newCachedThreadPool(); Producer producer1=new Producer(vector,size); Producer producer2=new Producer(vector,size); Producer producer3=new Producer(vector,size); Consumer consumer1=new Consumer(vector); Consumer consumer2=new Consumer(vector); Consumer consumer3=new Consumer(vector); executorService.execute(producer1); executorService.execute(producer2); executorService.execute(producer3); executorService.execute(consumer1); executorService.execute(consumer2); executorService.execute(consumer3); Thread.sleep(1000); producer1.stop(); producer2.stop(); producer3.stop(); Thread.sleep(3000); executorService.shutdown(); }} 输出示例12345678910111213141516171819202122232425262728293031323334start product id= 11start product id= 12start product id= 13start consumer id= 14start consumer id= 15start consumer id= 16Queue is empty: ,consumer 14 is running,size=0create data:1,size:1consumer consume data: 1,size: 0Queue is empty: ,consumer 14 is running,size=0create data:2,size:1consumer consume data: 2,size: 0create data:3,size:1create data:4,size:2consumer consume data: 3,size: 1create data:5,size:2consumer consume data: 4,size: 1consumer consume data: 5,size: 0Queue is empty: ,consumer 15 is running,size=0Queue is empty: ,consumer 14 is running,size=0Queue is empty: ,consumer 16 is running,size=0create data:6,size:1consumer consume data: 6,size: 0Queue is empty: ,consumer 14 is running,size=0Queue is empty: ,consumer 15 is running,size=0create data:7,size:1consumer consume data: 7,size: 0Queue is empty: ,consumer 14 is running,size=0Queue is empty: ,consumer 15 is running,size=0create data:8,size:1consumer consume data: 8,size: 0Queue is empty: ,consumer 14 is running,size=0Queue is empty: ,consumer 15 is running,size=0Queue is empty: ,consumer 16 is running,size=0 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <categories>
        <category>算法与数据结构</category>
      </categories>
      <tags>
        <tag>手撕算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[链表浅谈]]></title>
    <url>%2F2019%2F08%2F30%2F%E9%93%BE%E8%A1%A8%E6%B5%85%E8%B0%88%2F</url>
    <content type="text"><![CDATA[链表介绍 增加了虚拟头结点，即在索引0前面还有头结点，只需要遍历index次就可到达index的位置。 使用了内部类，即Node类 基本实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149public class LinkedList_New { class Node { private E e; private Node next; public Node(E e, Node next) { this.e = e; this.next = next; } public Node(E e) { this(e, null); } public Node() { this(null, null); } @Override public String toString() { return e.toString(); } } public int size; public Node dummyhead;// 虚拟头结点 public LinkedList_New() { size = 0; dummyhead = new Node(null, null); } public int getSize() { return size; } public boolean isEmpty() { return size == 0; } //向头结点插入元素，则关键在于iNULL3->2->1->0->NULL4->3->2->1->0->NULL4->3->66->2->1->0->NULL4->3->66->1->0->NULL3->66->1->0->NULL3->66->1->NULL 链表实现栈123456789101112131415161718192021222324252627282930313233public class LinklistStack implements Stack { private LinkedList_New list; public LinklistStack() { this.list = new LinkedList_New(); } @Override public int getSize() { return list.getSize(); } @Override public boolean isEmpty() { return list.isEmpty(); } @Override public void push(E e) { list.addNode(e);; } @Override public E pop() { return list.deleteFirst(); } @Override public E peek() { return list.getFirst(); } @Override public String toString() { StringBuilder stringBuilder=new StringBuilder(); stringBuilder.append("Stack: top "); stringBuilder.append(list); return stringBuilder.toString(); }} 性能比较与数组实现的栈进行入栈出栈的性能比较。 1234567891011121314151617181920212223import java.util.Random;public class StackTimeTest { public static double QueueTest(Stack s,int count) { long start=System.currentTimeMillis(); Random random=new Random(); for(int i=0;i < count;i++) { s.push(random.nextInt(Integer.MAX_VALUE)); } for(int i=0;i < count;i++) { s.pop(); } long end=System.currentTimeMillis(); return (end-start)/1000.0; } public static void main(String[] args) { int count=10000; double time1=QueueTest(new LinklistStack(), count); System.out.println("LinklistStack: "+time1+"s"); double time2=QueueTest(new ArrayStack(), count); System.out.println("ArrayStack: "+time2+"s"); } } 结果显示12LinklistStack: 0.006sArrayStack: 0.002s LinklistStack中包含更多的new 操作，增加了一定的时间复杂度。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <categories>
        <category>算法与数据结构</category>
      </categories>
      <tags>
        <tag>底层实现</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[煮酒论队列]]></title>
    <url>%2F2019%2F08%2F29%2F%E7%85%AE%E9%85%92%E8%AE%BA%E9%98%9F%E5%88%97%2F</url>
    <content type="text"><![CDATA[循环队列循环队列介绍 存在front和tail指针，当front==tail时，队列为空，当添加元素时，队列末尾指针即tail+1，而元素出队列时，则队列头指针front+1。 当（tail+1）%c ==front时，则队列满。实际上，对于整个队列来说，当队列满时，则实际上还剩余一个空间。 基本实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798public class LoopQueue implements Queue { public E[] data; //声明头指针和尾指针 public int front, tail; public int size; public LoopQueue(int capicity) { this.data = (E[]) new Object[capicity + 1]; front = 0; tail = 0; size = 0; } public LoopQueue() { this(10); } //由循环队列满的条件可知，队列元素的数量是整个队列长度-1 public int getCapicty() { return data.length-1; } @Override public int getSize() { return size; } @Override public boolean isEmpty() { return front==tail; } //入队操作，在队列满的条件下，进行扩容操作，对tail进行取余操作。这是与数组添加元素不一样的地方。 @Override public void enqueue(E e) { if((tail+1)%data.length==front) { resize(getCapicty()*2); } data[tail]=e; tail=(tail+1)%data.length; size++; } //扩容操作，声明一个新数组。 private void resize(int capicity) { E[] data_new=(E[]) new Object[capicity+1];// for(int i=0;i < size;i++) {// data_new[i]=data[(i+front)%data.length];// } for(int i=front;i!=tail;i=(i+1)%data.length) { data_new[i-front]=data[i]; } data=data_new; front=0; tail=size; } //出队操作，可以手动将队列头指针置为null，提醒GC进行回收，不影响最终的结果。 @Override public E dequeue() { if(isEmpty()) { throw new IllegalArgumentException("队列为空"); } E val=data[front];// data[front]=null; front=(front+1)%data.length; size--; if(size==getCapicty()/4 && getCapicty()/2!=0) { resize(getCapicty()/2); } return val; } @Override public E getFront() { if(isEmpty()) { throw new IllegalArgumentException("队列为空"); } return data[front]; } @Override public String toString() { StringBuilder stringBuilder = new StringBuilder(); stringBuilder.append(String.format("Queue size = %d,length: %d", size, getCapicty())); stringBuilder.append("front ["); for (int i = front; i != tail; i=(i+1)%data.length) { stringBuilder.append(data[i]); if ((i+1)%data.length!=tail) { stringBuilder.append(","); } } stringBuilder.append("] tail"); return stringBuilder.toString(); }} 测试示例123456789101112131415public class LoopQueueTest { public static void main(String[] args) { LoopQueue loopQueue=new LoopQueue(); for(int i=0;i1->NULL tail Queue Front: 0->1->2->NULL tail Queue Front: 1->2->NULL tail Queue Front: 1->2->3->NULL tail Queue Front: 1->2->3->4->NULL tail Queue Front: 1->2->3->4->5->NULL tail Queue Front: 2->3->4->5->NULL tail Queue Front: 2->3->4->5->6->NULL tail Queue Front: 2->3->4->5->6->7->NULL tail Queue Front: 2->3->4->5->6->7->8->NULL tail Queue Front: 3->4->5->6->7->8->NULL tail Queue Front: 3->4->5->6->7->8->9->NULL tail 性能比较与数组实现的队列以及链表实现的队列进行入队出队的性能比较。 12345678910111213141516171819202122232425262728import java.util.Random;public class QueueTimeTest { public static double QueueTest(Queue q,int count) { long start=System.currentTimeMillis(); Random random=new Random(); for(int i=0;i { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <categories>
        <category>算法与数据结构</category>
      </categories>
      <tags>
        <tag>底层实现</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[实现栈]]></title>
    <url>%2F2019%2F08%2F29%2F%E5%AE%9E%E7%8E%B0%E6%A0%88%2F</url>
    <content type="text"><![CDATA[创建功能接口1234567public interface Stack { int getSize(); boolean isEmpty(); void push(E e); E pop(); E peek();} 实现栈的功能借助之前实现的数组类，主要调用addLast和deleteLast方法。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556public class ArrayStack implements Stack { Array array; public ArrayStack(int capacity) { array = new Array(capacity); } public ArrayStack() { array=new Array(); } @Override public int getSize() { return array.getSize(); } @Override public boolean isEmpty() { return array.isEmpty(); } public int getCapicity() { return array.getCapacity(); } @Override public void push(E e) { array.addLast(e); } @Override public E pop() { return array.deleTeLast(); } @Override public E peek() { return array.getLast(); } @Override public String toString() { StringBuilder stringBuilder = new StringBuilder(); stringBuilder.append("Stack:"); stringBuilder.append("["); for (int i = 0; i < array.getSize(); i++) { stringBuilder.append(array.find(i)); if (i != array.getSize() - 1) { stringBuilder.append(","); } } stringBuilder.append("] top"); return stringBuilder.toString(); }} 测试类12345678910111213public class ArrayStackTest { public static void main(String[] args) { ArrayStack arrayStack=new ArrayStack() ; for(int i=0; i < 5;i++) { arrayStack.push(i); System.out.println(arrayStack); } arrayStack.pop(); System.out.println(arrayStack); }} 输出示例123456Stack:[0] topStack:[0,1] topStack:[0,1,2] topStack:[0,1,2,3] topStack:[0,1,2,3,4] topStack:[0,1,2,3] top document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <categories>
        <category>算法与数据结构</category>
      </categories>
      <tags>
        <tag>底层实现</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[实现数组类]]></title>
    <url>%2F2019%2F08%2F29%2F%E5%AE%9E%E7%8E%B0%E6%95%B0%E7%BB%84%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[实现一个数组类，实现了泛型，以及动态扩容。 内部实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184public class Array { public T[] data; private int count; //提供两个构造器 public Array(int num) { this.data = (T[]) new Object[num]; this.count = 0; } public Array() { this(10); } // 获得数组中元素个数 public int getSize() { return count; } // 获得数组长度 public int getCapacity() { return data.length; } // 判断数组是否为空 public boolean isEmpty() { return count == 0; } // 向所有元素后面添加一个新元素 public void addLast(T e) { insert(count, e); } // 向所有元素前面添加一个新元素 public void addFirst(T e) { insert(0, e); } // 插入新元素 public void insert(int index, T value) { if (data.length == count) { resize(); } if (index < 0 || index > count) { throw new IllegalArgumentException("数组已满"); } // 其中数组索引都是从0开始，所以起始位置已经是最后一个元素的下一位 for (int i = count; i > index; --i) { data[i] = data[i - 1]; } data[index] = value; ++count; } // 获取index位置的元素 public T find(int index) { if (index < 0 || index >= count) { throw new IllegalArgumentException("数组越界"); } else { return data[index]; } } // 修改数组中index位置的元素值 public void set(int index, T e) { if (index < 0 || index >= count) { throw new IllegalArgumentException("数组越界"); } data[index] = e; } // 查找数组元素e所在的索引值 public int get(T e) { for (int i = 0; i < data.length; i++) { if (data[i] == e) { return i; } } return -1; } //获取数组的第一个元素值 public T getFirst() { return find(0); } //获取数组的最后一个元素值 public T getLast() { return find(count-1); } // 删除元素，并返回元素值 public T delete(int index) { if (index < 0 || index >= count) { throw new IllegalArgumentException("数组越界"); } T ret = data[index]; for (int i = index + 1; i < count; i++) { data[i - 1] = data[i]; } if (count > 1)]; System.arraycopy(data, 0, newArray, 0, data.length); data = (T[]) newArray; } //缩小成原来的2倍 private void resize_less() { Object[] newArray = new Object[data.length/2]; System.arraycopy(data, 0, newArray, 0, count); data = (T[]) newArray; } // 重写打印方法 @Override public String toString() { StringBuilder stringBuilder = new StringBuilder(); stringBuilder.append(String.format("Array:size= %d,length: %d", count, data.length)); stringBuilder.append("["); for (int i = 0; i < count; i++) { stringBuilder.append(data[i]); if (i != count - 1) { stringBuilder.append(","); } } stringBuilder.append("]"); return stringBuilder.toString(); } public static void main(String[] args) { Array array = new Array(20); for (int i = 0; i < 10; i++) { array.addLast(i); } System.out.println(array); array.insert(3, 6); System.out.println(array); array.addFirst(-3); System.out.println(array); array.delete(2); System.out.println(array); array.deleteFirst(); System.out.println(array); array.removeElement(4); System.out.println(array); array.removeElement(3); System.out.println(array); array.addLast(4); array.addLast(7); array.addLast(8); System.out.println(array); }} 输出示例12345678Array:size= 10,length: 20[0,1,2,3,4,5,6,7,8,9]Array:size= 11,length: 20[0,1,2,6,3,4,5,6,7,8,9]Array:size= 12,length: 20[-3,0,1,2,6,3,4,5,6,7,8,9]Array:size= 11,length: 20[-3,0,2,6,3,4,5,6,7,8,9]Array:size= 10,length: 20[0,2,6,3,4,5,6,7,8,9]Array:size= 9,length: 10[0,2,6,3,5,6,7,8,9]Array:size= 8,length: 10[0,2,6,5,6,7,8,9]Array:size= 11,length: 15[0,2,6,5,6,7,8,9,4,7,8] document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <categories>
        <category>算法与数据结构</category>
      </categories>
      <tags>
        <tag>底层实现</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git遇到的系列问题]]></title>
    <url>%2F2019%2F08%2F27%2Fgit%E9%81%87%E5%88%B0%E7%9A%84%E7%B3%BB%E5%88%97%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[出现you need to resolve your current index first报错提示当使用git checkout 切换分支时会提示you need to resolve your current index first，使用如下命令即可解决。 1$ git reset --merge github上显示commit的Author与账户名称不符进入git bash,重新进行配置 12$ git config --global user.name "xxx" $ git config --global user.email "xxx" 出现Updates were rejected because the tip of your current branch is behind报错提示说明当前的分支代码不是最新的代码，需要更新一下master分支 push前先将远程repository修改pull下来 123$ git checkout master$ git pull origin master$ git push -u origin master git push时出现Everything up-to-date报错提示 如果之前未提交过文件，而你在git push的时候出现Everything up-to-date，并且文件也没有提交上去。可能是因为你没有git add 和 git commit。 也可能是git提交改动到缓存，要push的时候不会将本地所有的分支都push掉，所以出现这个问题。应该告诉git提交哪个分支。 这里有种特殊的情况是如果fork别人的仓库再clone到本地的话，即使git上只有一个主分支，他还是可能出现这个错误。那么我们就需要新建分支提交改动然后合并分支。 接下来先创建一个新分支提交改动 1$ git branch newbranch 然后输入这条命令检查是否创建成功 1$ git branch 终端输出 12 newbranch* master 这样就创建成功了，前面的*代表的是当前所在的工作分支。接下来就要切换工作分支。 1$ git checkout newbranch 可以 $ git branch 确认下。然后将改动提交到新的分支上。 12$ git add .$ git commit -a 此时可以 $ git status 检查下提交情况。如果提交成功，接下来就要回主分支了，代码和之前一样。 1$ git checkout master 然后将新分支提交的改动合并到主分支上 1$ git merge newbranch 合并分支可能产生冲突，下面的代码可以查看产生冲突的文件，然后做对应的修改再提交一次就可以了。 1$ git diff 接下来就可以push代码了。 1$ git push -u origin master 最后不能忘记删除分支 1$ git branch -D newbranch 如想保留分支只是想删除已经合并的部分只要把大写的D改成小写的d就行了。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>问题集合</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python技巧（2）]]></title>
    <url>%2F2019%2F08%2F21%2Fpython-skill-2%2F</url>
    <content type="text"><![CDATA[any的用法1if any(name.endwith('py') for name in files） 其中如startwith()与endwith()方法中如果有多个可匹配对象，必须输入一个元组。 分割字符串使用了多个界定符的情况下,界定符可以是逗号，分号，或者是空格，并且后面紧跟着任意个空格。需要注意是否使用了括号即捕获分组，形如(?:….)为非捕获分组。 12line='asdf fnfkjdjs,djjwe;djwe' a=re.split(r'(?:;|,|\s)\s*',line) 生成器表达式 如果想将字符串strip操作和其他迭代操作相结合，可以使用生成器表达式 1lines=(line.strip() for line in f 这种方式十分高效，因为不需要预先读取所有数据放到一个临时列表，仅仅只是创建一个生成器。 使用 + 操作符去连接大量的字符串效率低下，加号连接引起内存复制以及垃圾回收操作。也可以利用生成器表达式转换字符串并合并。 12data=['acm',3,4,5]dada_new=','.join(str(d) for d in data) python3.8新特性使用asyncio.run()高级API 12345678910import asyncioasync def print_hello(): print('hello') await asyncio.sleep(1) print('hello again')print('开始运行')asyncio.run(print_hello())print('进入循环') 函数的嵌套函数嵌套能保证内部函数的隐私，只能被外部函数所调用和访问，不会暴露在全局作用域，若函数内部有一些隐私数据（数据库用户以及密码),不想暴露在外面，就可以使用函数嵌套。 12345def connect(): def get_DB(): return host,username,password conn = connector.connect(get_DB()) return conn 同样的，合理使用函数嵌套，也可以提高程序的运行效率。使用递归的方式来计算一个数的阶乘，在计算之前，要检查输入是否合法。写成函数嵌套的话，输入是否合法只检查一次，而不使用嵌套的话，每调用一次递归，就会检查一次。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>相关技巧</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode:最长的斐波那契子序列的长度]]></title>
    <url>%2F2019%2F08%2F19%2Fleetcode-%E6%9C%80%E9%95%BF%E7%9A%84%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E5%AD%90%E5%BA%8F%E5%88%97%E7%9A%84%E9%95%BF%E5%BA%A6%2F</url>
    <content type="text"><![CDATA[题目内容如果序列 X_1, X_2, …, X_n 满足下列条件，就说它是 斐波那契式 的：n >= 3对于所有 i + 2 2 else 0 其中使用了迭代法，主要在于嵌套了三层循环，while的使用很重要。 Java解法1123456789101112131415161718192021class Solution { public int lenLongestFibSubseq(int[] A) { Map map=new HashMap(); for(int a=0;a < A.length;a++){ map.put(A[a],a); } int length=0; Map dict=new HashMap(); for(int k=0;k < A.length;++k){ for(int j=0;j < k;++j){ int result=map.getOrDefault(A[k]-A[j],-1); if (result=0){ int camp=dict.getOrDefault(result*A.length+j,2)+1; dict.put(j*A.length+k,camp); length=Math.max(length,camp); } } } return length>2 ? length :0; }} 使用动态规划，其中getOrDefault函数是可以获取对应键的值，如果值不存在，则提供第二个参数为默认值。可以将该问题抽象出数组索引的最长子序列问题，表达式为len(A[i,j])+1=len(A[j,k]),其中A[i,j]可以表示为i*A.length+j,若使用例如i+j来代替,则有的测试用例无法通过。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <categories>
        <category>算法与数据结构</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode:实现strStr()]]></title>
    <url>%2F2019%2F08%2F16%2Fleetcode-%E5%AE%9E%E7%8E%B0strStr%2F</url>
    <content type="text"><![CDATA[题目内容实现 strStr() 函数。 给定一个 haystack 字符串和一个 needle 字符串，在 haystack 字符串中找出 needle 字符串出现的第一个位置 (从0开始)。如果不存在，则返回 -1。 示例示例 1: 输入: haystack = “hello”, needle = “ll” 输出: 2 示例 2: 输入: haystack = “aaaaa”, needle = “bba” 输出: -1 类似C语言的 strstr() 以及 Java的 indexOf()函数。 python解法11234567891011class Solution(object): def strStr(self, haystack, needle): """ :type haystack: str :type needle: str :rtype: int """ for i in range(len(haystack)-len(needle)+1): if(haystack[i:len(needle)+i])==needle: return i return -1 重点在于循环范围是两个字符串的差值。 java解法11234567891011121314151617181920class Solution { public int strStr(String haystack, String needle) { if(needle.equals("")){ return 0; } if(haystack.equals("")){ return -1; } for(int i=0;ihaystack.length()) { return -1; } if(haystack.substring(i,i+needle.length()).equals(needle)){ return i; } } return -1; }} 该解法类似于python解法1，不过java要比python多出一些边界条件的限制，i+len(needle)与len(haystack）要进行比较，否则substring要报异常。 java解法2123456789101112131415161718192021222324252627282930class Solution { public int strStr(String haystack, String needle) { if(needle.equals("")){ return 0; } if(haystack.equals("")){ return -1; } if (haystack.equals(needle)){ return 0; } int j=0; int i; for(i=0;i < haystack.length();i++){ if (j==needle.length()){ return i-j; } if(haystack.charAt(i)==needle.charAt(j)){ ++j; }else{ i-=j; j=0; } } if (j==needle.length()){ return i-j; } return -1; }} 注意：存在这样一个测试用例： 12"mississippi""issip" 之所以在else语句里要加i=i-j，是因为需要考虑到之前有部分匹配的情况，需要将i返回到起初的下一位置。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <categories>
        <category>算法与数据结构</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[解决Maven索引补全问题]]></title>
    <url>%2F2019%2F08%2F16%2F%E8%A7%A3%E5%86%B3Maven%E7%B4%A2%E5%BC%95%E8%A1%A5%E5%85%A8%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[Maven无法自动补全依赖库 将下载好的spring的jar包放在./m2/responsity中，之后在maven的setting中手动更新本地仓库的jar索引来解决。 打开设置界面，选中本地的仓库，点击右上角的update，更新maven仓库索引。 这样对于已经下载到本地的jar都可以自动进行补全了。 缺少resource文件夹，设置成resource boot，即mark dectionary as source boot,可以在该文件夹下面建立包。 在pom.xml文件中直接添加依赖，然后点击右上角搜索框，输入maven project,点击刷新，可以对依赖库进行自动下载。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <categories>
        <category>Maven</category>
      </categories>
      <tags>
        <tag>问题集合</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python技巧（1）]]></title>
    <url>%2F2019%2F07%2F05%2Fpython-skill-1%2F</url>
    <content type="text"><![CDATA[星号的作用python利用*号对可迭代的对象进行解压，并赋值给多个对象。示例代码如下： 1234record = ['lakers','76ers','warriors'] *teams,team = record print(*teams)out：lakers 76ers 星号表达式也可以应用于列表的开始部分以及字符串的分割，若想解压一些元素而不使用，则使用一个普通的’_’或’ign’即可。在迭代元素为可变长元组的序列时很有用。示例代码如下： 1234567891011records = [ ('no1','76ers'), ('no2','warriors'), ('no1','bull')]def bar(s): print('no1',s)for tag,*args in records: if tag == 'no1': bar(*args)out:no1 76ers no1 bull 其中records为一个带有标签的元组序列 如何保留最后N个元素示例代码如下： 1234567from collections import dequedef search(lines,pattern,history = 5): previous = deque(maxlen=history) for line in lines: if pattern in line: yield line,previous previous.append(line) 在多行上做简单的文本匹配，并返回匹配所在行的最后N行。使用deque（maxlen=N)构造函数会新建一个固定大小的队列。当新的元素加入并且这个队列已满，最老的元素会自动被移除掉。 dict创建字典dict.fromkeys(“[…],[…]”) 第一个参数指定keys，第二个参数指定value 实现一个简单的优先级队列示例代码如下：Item类 12345678class Item(): def __init__(self,name): self.name=name def __repr__(self): return 'Item({})'.format(self.name)q=Priority()q.push(Item('foo'),1)q.pop() 12345678910import heapqclass Priority(): def __init__(self): self._queue=[] self._index=0 def push(self,item,prior): heapq.heappush(self._queue,(-prior,self._index,item)) self._index+=1 def pop(self): return heapq.heappop(self._queue)[-1] 字典中的键映射多个值d=defaultdict(list)d=setdefault('a',[]).append(1) 去重（return和yield的区别)示例代码如下： 12345678def deque(items): a=set() for item in items: if item not in a: #yield item a.add(item) return ac=list(deque([1,4,6,7,2,56,2,1])) 若是不用return，用yield编写生成器。示例代码如下： 123456789def dedupe(items,key=None): a=set() for item in items: var=item if key is None else key(item) if var not in a: yield item a.add(var)seed=[{'x':1,'y':2},{'x':3,'y':7},{'x':1,'y':2}]d=list(dedupe(seed,key=lambda x:x['x'])) 关于命名切片 内置的slice()函数创建了一个切片对象，可以用在任何切片允许使用的地方。 indices(sizde)返回一个三元组(start,stop,step)，所有值都会被合适的缩小以满足边界限制，避免出现indexError异常。for i in range(*a.indices(len(list))) 关键字排序使用itertools.groupby函数，扫描整个序列，并且查找连续相同值的元素序列。在此之前，是要会根据分组的字段进行预先排序。示例代码如下：rows.sort(key=itemgetter('date'))for date,item in groupby(rows,key=itemgetter('date')): 字典表达式示例代码如下：p={key:value for key,value in dict1.items() if key in list1}p=dict((key,value) for key,value in dict1.items() if value>80) 命名元组示例代码如下： 1234from collections import namedtupleinfo=namedtuple('info',['name','age'])sub=info('Tom',18)sub.age 好处是避免使用下标操作让代码表意不清，且非常依赖代码的结构。如果需要改变属性的值，使用命名元组实例的_replace()方法，它会创建一个全新的命名元组并将对应的字段用新的值来代替。当命名元组拥有可选或缺失字段的情况下，可以利用命名元组来填充数据，先创建一个包含缺省值的原型元组，使用_replace()方法创建新的值。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>相关技巧</tag>
      </tags>
  </entry>
</search>
